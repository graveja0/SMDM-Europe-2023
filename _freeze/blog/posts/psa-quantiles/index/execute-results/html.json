{
  "hash": "9ecb73185d6998f0fec703254222097d",
  "result": {
    "markdown": "---\ntitle: \"Parameters for Distributions\"\neditor: visual\neditor_options: \n  chunk_output_type: console\n---\n\n\n[Source](https://www.johndcook.com/quantiles_parameters.pdf) [Another source](https://forum.effectivealtruism.org/posts/tvTqRtMLnJiiuAep5/how-to-determine-distribution-parameters-from-quantiles) [Excel Functions](https://docs.google.com/spreadsheets/d/1noozmyQvdqVXB8lH1JP1P7e6g-0FSV-9Q1EZS3Gh220/edit#gid=0)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.1      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.5.0 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n:::\n\n\n# Normal Distribution\n\n$$\n\\sigma = \\frac{x_2 - x_1}{\\Phi^{-1}(p_2)-\\Phi^{-1}(p_1)}\n$$ {#eq-norm.sigma}\n\n$$\n\\mu = \\frac{x_1\\Phi^{-1}(p_2)-x_2\\Phi^{-1}(p_1)}{\\Phi^{-1}(p_2)-\\Phi^{-1}(p_1)}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 <- qnorm(0.1,1.3,.2)\np1 <- 0.1\n\nx2 <- qnorm(0.9,1.3,.2)\np2 <- 0.9\n\nparam_normal <- function(x1,x2,p1,p2) {\n    sigma = (x2 - x1) / (qnorm(p2,0,1)-qnorm(p1,0,1)); sigma\n    mu <- (x1*qnorm(p2,0,1)-x2*qnorm(p1,0,1))/(qnorm(p2,0,1)-qnorm(p1,0,1)); mu\n    \n    c(\"mu\" = mu, \"sigma\" = sigma)\n}\n```\n:::\n\n\n# Gamma\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 <- 0.6\nx2 <- 0.8\np1 <- 0.1\np2 <- 0.9\n\ngamma_fn <- function(alpha) {\n    x1*qgamma(p2,shape = alpha, scale =1) - x2 * qgamma(p1, shape = alpha, scale = 1)\n}\n\ncalc_beta <- function(x1,p1,alpha) {\n    x1 / qgamma(p1,alpha,1)\n}\n\ncurve(gamma_fn, xlim = c(1,100), col = \"blue\", lwd = 1.5, lty=2)\nabline(a=0,b=0)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n\n```{.r .cell-code}\nalpha_ <- uniroot(gamma_fn,c(70,85))$root; alpha_\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 79.74756\n```\n:::\n\n```{.r .cell-code}\nbeta_ <- calc_beta(x1 = x1,  p1 = p1, alpha = alpha_); beta_\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.008754199\n```\n:::\n\n```{.r .cell-code}\n# Check the answer\nqgamma(0.1,shape = alpha_, scale = beta_)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.6\n```\n:::\n\n```{.r .cell-code}\nqgamma(0.9,shape = alpha_, scale = beta_)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.8\n```\n:::\n\n```{.r .cell-code}\nparam_gamma <- function(x1,x2,p1,p2,range) {\n    alpha_ <- uniroot(gamma_fn,range)$root; alpha_\n    beta_ <- calc_beta(x1 = x1,  p1 = p1, alpha = alpha_); beta_\n    \n    c(\"alpha\" = alpha_, \"beta\" = beta_)\n}\nparam_gamma(x1= x1, x2 = x2, p1 = p1, p2 = p2, range = c(60,100))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       alpha         beta \n79.747557736  0.008754199 \n```\n:::\n:::\n\n\n# Beta Distribution\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Source: https://stats.stackexchange.com/questions/112614/determining-beta-distribution-parameters-alpha-and-beta-from-two-arbitrary\n\nx1 <- 0.6\nx2 <- 0.8\np1 <- 0.1\np2 <- 0.9\n\n# Logistic transformation of the Beta CDF.\nf.beta <- function(alpha, beta, x, lower=0, upper=1) {\n  p <- pbeta((x-lower)/(upper-lower), alpha, beta)\n  log(p/(1-p))\n}\n\n# Sums of squares.\ndelta <- function(fit, actual) sum((fit-actual)^2)\n\n# The objective function handles the transformed parameters `theta` and\n# uses `f.beta` and `delta` to fit the values and measure their discrepancies.\nobjective <- function(theta, x, prob, ...) {\n  ab <- exp(theta) # Parameters are the *logs* of alpha and beta\n  fit <- f.beta(ab[1], ab[2], x, ...)\n  return (delta(fit, prob))\n}\n\nx.p <- (function(p) log(p/(1-p)))(c(p1, p2))\nstart <- log(c(1e1, 1e1))\nsol <- nlm(objective, start, x=c(x1,x2), prob=x.p, lower=0, upper=1, typsize=c(1,1), fscale=1e-12, gradtol=1e-12)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in nlm(objective, start, x = c(x1, x2), prob = x.p, lower = 0, upper =\n1, : NA/Inf replaced by maximum positive value\n\nWarning in nlm(objective, start, x = c(x1, x2), prob = x.p, lower = 0, upper =\n1, : NA/Inf replaced by maximum positive value\n```\n:::\n\n```{.r .cell-code}\nparams <- exp(sol$estimate); params\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 23.70741 10.03106\n```\n:::\n\n```{.r .cell-code}\nqbeta(p = c(p1, p2), params[1], params[2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.6000000 0.8000001\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 1: Define the parameters and uncertainty distributions.\n\nw1 = 2\nw1.low = 1.75\nw1.hi = 2.25\np1.low = 0.1\np1.hi = 0.9\n\nc1 = 1\nc1.low = 1\nc1.hi = 1\np1.low = 0.1\np1.hi = 0.9\n\nw2 = 1\nw2.low = 1\nw2.hi = 1\n\nc2 = 0.85\nc2.low = 0.75\nc2.hi = 0.95\np2.low = 0.1\np2.hi = 0.9\n\nx1 = c2.low\nx2 = c2.hi\np1 = p2.low\np2 = p2.hi\ndist = \"unif\"\n\nget_dist_params <- function(x1, x2, p1, p2, dist = \"unif\", range = NULL) {\n    \n    if (dist==\"unif\") {\n        get_min_unif <- function(x1, x2, p1, p2) {\n            (p2*x1-p1*x2) / (p2 - p1) \n        }\n        get_max_unif <- function(x1, x2, p1 , p2) {\n            ((1-p1)*x2-(1-p2)*x1)/(p2-p1)\n        }\n        get_avg_unif <- function(x1, x2, p1, p2) {\n            mean(c(get_min_unif(x1 = x1, x2 = x2, p1 = p1, p2 = p2),\n                   get_max_unif(x1 = x1, x2 = x2, p1 = p1, p2 = p2)))\n        }\n        \n        params <- c(mean = get_avg_unif(x1 = x1, x2 = x2, p1 = p1, p2 = p2), \n                    median = get_avg_unif(x1 = x1, x2 = x2, p1 = p1, p2 = p2),\n                    min = get_min_unif(x1 = x1, x2 = x2, p1 = p1, p2 = p2),\n                    max = get_max_unif(x1 = x1, x2 = x2, p1 = p1, p2 = p2))\n        attr(params,\"dist\") = \"uniform\"\n    }\n    \n    if (dist == \"norm\") {\n        param_norm <- function(x1,x2,p1,p2) {\n            sigma = (x2 - x1) / (qnorm(p2,0,1)-qnorm(p1,0,1)); sigma\n            mu <- (x1*qnorm(p2,0,1)-x2*qnorm(p1,0,1))/(qnorm(p2,0,1)-qnorm(p1,0,1)); mu\n            \n            c(\"mean\" = mu, \"sd\" = sigma)\n        }\n        \n        params = param_norm(x1 = x1, x2 = x2, p1 = p1, p2 = p2)\n        attr(params,\"dist\") = \"normal\"\n    }\n    \n    if (dist == \"lognorm\") {\n        get_mean_of_log <- function(x1, x2, p1, p2) {\n            (qnorm(p2,0,1)*log(x1)-qnorm(p1,0,1)*log(x2)) / (qnorm(p2,0,1)-qnorm(p1,0,1))\n        }\n        mean_of_log <- get_mean_of_log(x1 = x1, x2 = x2, p1 = p1, p2 = p2)\n        \n        get_sd_of_log <- function(x1, x2, p1 , p2) {\n            (log(x2) - log(x1)) / (qnorm(p2,0,1) - qnorm(p1,0,1))\n        }\n        sd_of_log <- get_sd_of_log(x1 = x1, x2 = x2, p1 = p1, p2 = p2)\n        \n        # params <- c(\"mean\" = exp(get_mean_of_log(x1 = x1, x2 = x2, p1 = p1, p2 = p2) + 0.5 * get_sd_of_log(x1 = x1, x2 = x2, p1 = p1, p2 = p2)^2),\n        #   \"median\" = exp(get_mean_of_log(x1 = x1, x2 = x2, p1 = p1, p2 = p2)),\n        #   \"sd\" = sqrt((exp(get_sd_of_log(x1 = x1, x2 = x2, p1 = p1, p2 = p2)^2)-1) * exp(2 * get_mean_of_log(x1 = x1, x2 = x2, p1 = p1, p2 = p2) + \n        #                                                                                      get_sd_of_log(x1 = x1, x2 = x2, p1 = p1, p2 = p2)^2)))\n        \n        params <- c(\"mean_log\" = get_mean_of_log(x1 = x1, x2 = x2, p1 = p1, p2 = p2), \n                    \"sd_log\" = get_sd_of_log(x1 = x1, x2 = x2, p1 = p1, p2 = p2))\n        attr(params,\"dist\") = \"lognormal\"\n\n    }\n    \n    if (dist == \"gamma\") {\n        gamma_fn <- function(alpha) {\n            x1*qgamma(p2,shape = alpha, scale =1) - x2 * qgamma(p1, shape = alpha, scale = 1)\n        }\n        \n        calc_beta <- function(x1,p1,alpha) {\n            x1 / qgamma(p1,alpha,1)\n        }\n        \n        #curve(gamma_fn, xlim = c(1,100), col = \"blue\", lwd = 1.5, lty=2)\n        #abline(a=0,b=0)\n        \n        alpha_ <- uniroot(gamma_fn,c(1,100))$root; alpha_\n        beta_ <- calc_beta(x1 = x1,  p1 = p1, alpha = alpha_); beta_\n    }\n    return(params)\n    \n}\n\n\nget_dist_params(x1 = w1.low, x2 = w1.hi, p1 = p1.low, p2 = p1.hi, dist = \"lognorm\" )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndisc_power <- function(fit) {\n    beta.hat <- fit[\"W\",]\n    accept <- 1-as.integer(dplyr::between(0,beta.hat[,2],beta.hat[,3]))\n    return(accept)\n}\n\nX_W(n_=1000, p_treat=0.5, tau=60) %>% \n    est() %>% \n    disc_power()\n\n\nval.stat.life = 9600000\n\nsurv.1 <- 0.987\nsurv.0 <- 0.97\n\nval.stat.life*(surv.1-surv.0)\n\n\nw.eitc <- 1\nc.eitc <- rgamma(1e3,rate = 89,shape=1); mean(c.eitc)\n\nhttps://www.johndcook.com/quantiles_parameters.pdf\n\n\nqnorm(0.1, mean = 1, sd = 1)\n\nx1 <- qnorm(0.1,1.3,.2)\np1 <- 0.1\n\nx2 <- qnorm(0.9,1.3,.2)\np2 <- 0.9\n\nparam_normal <- function(x1,x2,p1,p2) {\n    sigma = (x2 - x1) / (qnorm(p2,0,1)-qnorm(p1,0,1)); sigma\n    mu <- (x1*qnorm(p2,0,1)-x2*qnorm(p1,0,1))/(qnorm(p2,0,1)-qnorm(p1,0,1)); mu\n    \n    c(\"mu\" = mu, \"sigma\" = sigma)\n}\n\nparam_normal(x1 = 3, p1 = .1, x2 = 5, p2 = .9)\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}