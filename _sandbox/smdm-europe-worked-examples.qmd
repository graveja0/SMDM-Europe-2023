---
title: "SMDM Europe Worked Examples"
editor_options: 
  chunk_output_type: console
execute:
  code-fold: true
  message: false
  warning: false  
  cache: true
reference-location: margin
self-contained: true
editor: 
  markdown: 
    wrap: 72
---

# Outline

## 1. Alive-Dead
  - Estimate a mortality model to parameterize background mortality.
  - Verify that a discrete time Markov model can replicate life-expectancy at age X.
  
## 2. Healthy-Sick-Dead

  - Split "Alive" health state into healthy vs. sick
  - Don't add in cause-specific mortality yet.
  - Verify that a discrete time Markov model can replicate life-expectancy at age X.
  
## 3. Healthy-Sick-DeadSick-Dead

  - Add a cause-specific death category.
  - Show that if we assume a static hazard ratio for death (applied to the secular death rate) we will dramatically understate overall life expectancy.
  - Construct a cause-deleted life table, and use the cause deleted secular deaths instead.
  - Model using cause-specific death rate from the cause-deleted life table data. 
    - Show how you could also use a modeled death estimate that reduces the number of parameters, rather than an age-specific estimate from the life table. 

## 4. Competing Risks and Jumpover States 
  

```{r setup}
#| cache: false
#| warning: false
#| message: false
#| echo: false
#| code-fold: true
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)

library(tidyverse)
library(knitr)
library(kableExtra)
library(survival)
library(flexsurv)
library(haven)
library(dampack)
library(Matrix)
library(here)
library(glue)
library(demography)
library(glue)
library(MortalityLaws)
library(demography)
library(MASS)
options("scipen" = 100, "digits" = 5)

select <- dplyr::select
edit.na <- function(x, value) { x[is.na(x)] <- value; x}

theme_set(hrbrthemes::theme_ipsum())

ProbToRate = function(prob, t){
  -log(1-prob)/t
}

RateToProb = function(rate, t){
  1 - exp(-rate*t)
}

```

# Setup the Underlying Model 

## Parameters

We begin by specifying a parameter object that will ultimately guide the discrete time model. 

```{r}
#| warning: false
#| message: false
#| echo: true
#| code-fold: false
params <- list(
  n_age_init = 55,
  n_age_max = 65,
  d_c = 0.03,
  d_e = 0.03, 
  n_sim = 1000,
  r_HS = 0.1,
  hr_SD = 1.9, # hazard ratio on rate
  # overall death
  # p_HD is the time-varying background mortality
  # p_SD is the time-varying background mortality * 1.9(Hazard Ratio)
  hr_HS_trt = 0.5,
  u_H = 1,
  u_S = 0.773,
  u_D = 0,
  c_H = 8494, # Non-CVD health care cost
  c_trt = 840,
  c_S = 3917 + 8494, # Cost of annual follow-up post ASCVD
  c_nonfatal_firstYr = 49348,
  c_fatal_firstYr = 16760,
  c_D = 0,
  cycle_length = 1,
  n_cycles = 10
)

v_names_states = c("Healthy", "Sick", "Death")
n_states = length(v_names_states)
v_names_str = c("quo","trt")
n_strategies = length(v_names_str)
```

## Underlying Life-Table Data

Background mortality will be based on a mortality model. This reduces the parameterization from the total number of age bins in the life table data to only a few parameters that can be used to characterize background mortality. 

First we download and store the vital statistics data for the US from the human mortality database:

```{r, eval = FALSE}
#| warning: false
#| message: false
#| echo: false
#| code-fold: true
hmd.usa <- demography::hmd.mx("USA",username = "TK", password = "TK", "USA")
write_rds(hmd.usa,file=here("_sandbox/mortality/usa-life-table.rds"))
```

### Mortality Model

Next we construct a life table from these data. This is done using the `demography` package. 

```{r}
#| warning: false
#| message: false
#| echo: true
#| code-fold: false
#############################################
# Define Parameters for Life Table Modeling
#############################################
mort_year =  # Year to obtain from Human Mortality Database
  2019
N = # Population basis for life table
  100000
max_age =  # Max age in life table
  99
min_age =  # Min age in life table
  0
n_cycles =  # Number of discrete time (annual) cycles in Markov
  100

###############################
# Underlying Life-Table Data
###############################

lt <-  # Read in the U.S. life table data from the human mortality database.
  read_rds(here("_sandbox/mortality/usa-life-table.rds")) %>% 
  lifetable(.,series = "total", years = mort_year) %>% 
  as_tibble() %>% 
  mutate_at(vars(lx,dx), function(x) x*N) %>% 
  mutate(country = "USA") %>% 
  mutate(age = x)

lt %>% 
  ungroup() %>% 
  select(-x) %>% 
  select(country,age,everything()) %>% 
  head() %>% 
  kable() %>% 
  kable_styling()

```

The columns here are 

- `age`:	Ages for lifetable
- `year`: Period years or cohort years
- `mx`: 	Death rate at age x.
- `qx`: The probability that an individual of exact age x will die before exact age x+1.
- `lx`: Number of survivors to exact age x. This is defined relative to a **radix**, the number of individuals or the size of a cohort from which the life table is derived).
- `dx`: The number of deaths between exact ages x and x+1.
- `Lx`: Number of years lived between exact age x and exact age x+1.
- `Tx`: Number of years lived after exact age x.
- `ex`: Remaining life expectancy at exact age x.

Our next step is to fit a mortality model to these data. Generally speaking, we need three inputs:

- `age`
- `dx`
- `lx`

```{r}
foo <- availableLaws()
foo$table %>% 
  arrange(TYPE) %>% 
  kable() %>% 
  kable_styling()
```



Because we want to stay general (i.e., model all over the age spectrum), our first attempt  will be a Gompertz model. 

```{r}
#| warning: false
#| message: false
#| echo: false
#| code-fold: true


ages     <- lt$x[lt$x<=max_age & lt$x>=min_age]
deaths   <- lt$dx[lt$x<=max_age & lt$x>=min_age]
exposure <- lt$lx[lt$x<=max_age & lt$x>=min_age]

############################
# Fit the mortality model
############################
#availableLaws()

gom_fit <- MortalityLaw(
                x  = ages,
                Dx  = deaths,   # vector with death counts
                Ex  = exposure, # vector containing exposures
                law = "gompertz",
                opt.method = "LF2")
plot(gom_fit)
```

Gompertz doesn't fit all age ranges well. This is a well-known fact. Switching to another model. 

```{r}
#| warning: false
#| message: false
#| echo: false
#| code-fold: true
#| 
hp_fit <- MortalityLaw(
                x  = ages,
                Dx  = deaths,   # vector with death counts
                Ex  = exposure, # vector containing exposures
                law = "HP2",
                opt.method = "LF2")

plot(hp_fit)
```

Let's add the fitted mortality model parameters to our overall parameter list object. 


```{r}
#| warning: false
#| message: false
#| echo: true

params <- modifyList(params,
                     list(
                         heligman_bollard = unname(coef(hp_fit)),
                         gompertz = unname(coef(gom_fit))
                     ))
```


::: column-page
```{r}
#| warning: false
#| message: false
#| echo: false
#| code-fold: true
#| fig-cap: Fitted mortality rate vs. observed rate, by model 
#| label: fig-comparemodel
#| fig-align: center
#| fig-width: 10
#| fig-height: 10


res <- 
    availableLaws()$table %>% 
    #filter(row_number() %in% 1:12) %>% 
    pull(CODE) %>% 
    
    map_df(~({
        ages     <- lt$x[lt$x<=max_age & lt$x>=min_age]
        deaths   <- lt$dx[lt$x<=max_age & lt$x>=min_age]
        exposure <- lt$lx[lt$x<=max_age & lt$x>=min_age]
        fit <- 
            MortalityLaw(
                x  = ages,
                Dx  = deaths,   # vector with death counts
                Ex  = exposure, # vector containing exposures
                law = .x,
                opt.method = "LF2")
        
        df <- 
            tibble(age = as.numeric(paste0(names(fit$fitted.values))), prmort = fit$fitted.values, model = .x, type =fit$info$model.info$FIT)
        df
    })) 


res %>% ggplot(aes(x = age, y = log(prmort))) + geom_line(lwd=1) + 
    facet_wrap(~model) + 
    geom_point(data = lt, aes(x = age, y = log(mx)),alpha=0.2,size=0.1) + 
    ggsci::scale_colour_aaas() + 
    theme(legend.position = "none") + 
    ggthemes::theme_tufte(base_family = "Arial")

```
:::

## Mortality Markov

Now we'll answer the question: can we replicate life expectancy based on a life table using a discrete time Markov model? 

To do this, we'll consruct a very simple two-state discrete time Markov model.  We'll then parameterize the model with the coefficients from the mortality models above, and then calculate life expectancy with a QALY "payoff" of 1.0 if alive and no discounting. 

::: column-page

```{r, eval = FALSE}
#| echo: false
#| 
#https://sketchviz.com/new
# digraph G {
#     layout = neato;
#     Alive [pos="0,0!"];
#     Dead [pos="1,-1!"]
#     Alive -> Alive ;
#     Alive -> Dead [label="r_AD(t)"];
#     Dead -> Dead ;
#   }
```

![](media/digraph-alive-dead.png){fig-align="center" height="300px"}


:::

Let's start with a cohort of 40 year olds. Based on the life table, we should expect these individuals to live an additional `r  lt %>% filter(age==40) %>% pull(ex) %>% round(.,2)` years

```{r}
#| warning: false
#| message: false
#| echo: true
#| code-fold: false

starting_age = 40

tr_ <-  tr_alt_ <- # Start the Markov trace
  bind_rows(c("alive" = 1, "dead" = 0)) %>% mutate(t = 0) %>% select(t,alive,dead)

for (.x in 1:n_cycles) {
    r_death <- 
      HP2(.x + starting_age - 1, params$heligman_bollard)$hx
    
    ## Embedded Transition Probability Matrix
    m_Q <- # construct the transtiion rate matrix (2x2 for alive-dead)
        matrix(
            c(-(r_death), r_death, 0, 0),
            byrow = TRUE,
            ncol = 2,
            dimnames = list(c("alive", "dead"), c("alive", "dead"))
        )
    m_P <- # embed the transition probability matrix
        expm(m_Q)
    
    p_death <- 1 - exp(-r_death)
    
    ## Alternative version using standard rate-to-probability conversion formulas
    m_P_ <- 
      matrix(c((1 - p_death),p_death,0,1), byrow=TRUE,
             ncol=2,
             dimnames = list(c("alive","dead"),c("alive","dead")))
    
    tmp_ <-  # current state occupancy 
      c(tr_[.x, "alive"], tr_[.x, "dead"]) %>% unlist()
    
    tr_ <- # add next row of the Markov trace
        bind_rows(
            tr_,
            (tmp_ %*% m_P)  %>% 
              as.matrix() %>% 
              data.frame() %>% 
              mutate(t = .x) %>% 
              dplyr::select(t, alive, dead)
        )
    
    tmp_ <-  # current state occupancy 
      c(tr_alt_[.x, "alive"], tr_alt_[.x, "dead"]) %>% unlist()
    
    tr_alt_ <- # add next row of the Markov trace
        bind_rows(
            tr_alt_,
            (tmp_ %*% m_P_)  %>% 
              as.matrix() %>% 
              data.frame() %>% 
              mutate(t = .x) %>% 
              dplyr::select(t, alive, dead)
        )
    
}

# Cycle adjustment
cycle_adj <- 
    c(rep(c(4/3,2/3),n_cycles/2),1/3)
cycle_adj[1] <- 1/3

# Life-Expectancy via the discrete time Markov
payoff_lifeexp <- c(1,0)

life_exp_markov <- 
    t(cycle_adj) %*% tr_$alive 

life_exp_markov_alt <- 
    t(cycle_adj) %*% tr_alt_$alive 

# Life-Expectancy via the life table
life_exp_lifetable <- 
  lt %>% filter(age==starting_age) %>% pull(ex)

tibble(markov = as.vector(life_exp_markov), 
       markov_alt = as.vector(life_exp_markov_alt),life_table = life_exp_lifetable) %>% 
  kable(digits = 2) %>% 
  kable_styling()
```


We'll now loop through various starting ages to verify that we can replicate life expectancy with a simple discrete time Markov model.

```{r}
#| warning: false
#| message: false
#| echo: false
#| code-fold: true
#| fig-cap: Life Expectancy from Life Table vs. Modeled Mortality, by Cohort Starting Age and Model Type
#| label: fig-comparecohorts


model_ages <- c(0,80) 

healthy_dead <- function(starting_age, mort_model = "hp") {
    tr_ <-
        bind_rows(c("alive" = 1, "dead" = 0)) %>% mutate(t = 0) %>% select(t, alive, dead)
    
    for (.x in 1:n_cycles) {
        
        if (mort_model=="hp") r_death <- HP2(.x + starting_age - 1, params$heligman_bollard)$hx
        if (mort_model=="gom") r_death <- gompertz(.x + starting_age - 1,params$gompertz)$hx
        
        m_Q <-
            matrix(
                c(-(r_death), r_death, 0, 0),
                byrow = TRUE,
                ncol = 2,
                dimnames = list(c("alive", "dead"), c("alive", "dead"))
            )
        
        m_P <-
            expm(m_Q)
        
        tmp_ <- c(tr_[.x, "alive"], tr_[.x, "dead"]) %>% unlist()
        
        tr_ <-
            bind_rows(
                tr_,
                (tmp_ %*% m_P)  %>% as.matrix() %>% data.frame() %>% mutate(t = .x) %>% dplyr::select(t, alive, dead)
            )
        
    }
    
    # Cycle adjustment
    cycle <-
        c(rep(c(4 / 3, 2 / 3), n_cycles / 2), 1 / 3)
    cycle[1] <- 1 / 3
    
    # Life-Expectancy via the discrete time Markov
    life_exp <-
        t(cycle) %*% tr_$alive
    
    # Life-Expectancy via the life table
    life_exp_lt <- lt %>% filter(age == starting_age) %>% pull(ex)
    
    out <- data.frame(model = life_exp, lt = life_exp_lt)
    return(out)
}

res_compare <- 
    seq(0,80,2) %>% map_df(~healthy_dead(.x)) %>% 
    mutate(age = seq(0,80,2)) 
res_compare_gom <- 
    seq(0,80,2) %>% map_df(~healthy_dead(.x,mort_model="gom")) %>% 
    mutate(age = seq(0,80,2)) 
    

```

```{r}
#| fig-cap: Comparison of Modeled Life Expectancy from Mortality Models to Life Expectancy from Life Table
#| label: fig-comparison
#| warning: false
#| message: false
#| echo: false
#| code-fold: true
#| fig-width: 10
#| fig-height: 10
df_p <- 
    res_compare %>% 
    mutate(x_gom = res_compare_gom$model) %>% 
    gather(model,value,-lt,-age) %>% 
    mutate(model = factor(model, levels = c("model","x_gom"), labels = c("Heligman-Bollard","Gompertz")))

df_p %>% 
    ggplot(aes(x = value, y = lt, colour = model)) + geom_text(data = df_p %>% filter(model=="Heligman-Bollard"), aes(label = age),hjust=1.5,colour = "black") +  geom_point() +
    geom_abline(aes(slope=1,intercept = 0)) +
    labs(x = "Life Expectancy from Mortality Model",
         y = "Life Expectancy from Life Table") +
    ggsci::scale_colour_aaas(name="") +
    theme(legend.position = "top")
```

@fig-comparecohorts Shows that modeled life expectancy based on the Helligman-Bollard approach successfully replicates average life expectancy for nearly any age cohort. The figure also shows that the Gompertz model performs well among middle-aged adult cohorts (e.g., 40) but not for younger or older age cohorts. 

# Healthy-Sick-Dead

Let's now expand our simple model to include a "sick" state. For now we'll assume you're either healthy or sick, but that being sick does not confer a higher mortality rate:

![](media/digraph-healthy-sick-dead.png){fig-align="center" height="500px"}

::: column-page
```{r, eval = FALSE}
#| echo: false
# sketchviz code: 
digraph G {
    layout = neato;
    Healthy [pos="0,0!"];
    Sick [pos="1,1!"]; 
    Dead [pos="1,-1!"]
    Healthy -> Healthy ;
    Sick -> Sick;
    Healthy -> Sick [label="r_HS"]; 
    Sick -> Dead [label="  r_HD(t)"];
    Healthy -> Dead [label="r_HD(t)"];
    Dead -> Dead ;
  }
```
:::

Starting with a cohort aged 40, can we successfully replicate life expectancy again? 

```{r}
starting_age = .x = 40

tr_ <- tr_alt_ <- 
  bind_rows(c("healthy" = 1, "sick" = 0, "dead" = 0)) %>% mutate(t = 0) %>% select(t,healthy,sick,dead)

for (.x in 1:n_cycles) {
    
   r_death <- HP2(.x + starting_age - 1, params$heligman_bollard)$hx
    
    # Embedded Version
    m_Q <-
        matrix(
            c(-(r_death + params$r_HS), params$r_HS, r_death,
                0, -(r_death), r_death,
              0,0,0),
            byrow = TRUE,
            ncol = 3,
            dimnames = list(c("healthy", "sick","dead"), c("healthy", "sick","dead"))
        )
    
    m_P <-
        expm(m_Q)
    
    # Using Formulas to Convert
    p_death <- 1 - exp(-r_death)
    p_sick <- 1 - exp(-params$r_HS)
    
    m_P_ <- 
      matrix(c(
       (1-p_death - p_sick), p_sick, p_death,
       0,(1-p_death),p_death,
       0,0,1
      ),
      byrow=TRUE,
      ncol = 3,
            dimnames = list(c("healthy", "sick","dead"), c("healthy", "sick","dead"))
      )
    
    tmp_ <- c(tr_[.x, "healthy"], tr_[.x, "sick"], tr_[.x, "dead"]) %>% unlist()
    
    tr_ <-
        bind_rows(
            tr_,
            (tmp_ %*% m_P)  %>% as.matrix() %>% data.frame() %>% mutate(t = .x) %>% select(t,healthy,sick,dead)
        )
    
    tmp_ <- c(tr_alt_[.x, "healthy"], tr_alt_[.x, "sick"], tr_alt_[.x, "dead"]) %>% unlist()
    
    tr_alt_ <-
        bind_rows(
            tr_alt_,
            (tmp_ %*% m_P_)  %>% as.matrix() %>% data.frame() %>% mutate(t = .x) %>% select(t,healthy,sick,dead)
        )
    
}

# Cycle adjustment
cycle_adj <- 
    c(rep(c(4/3,2/3),n_cycles/2),1/3)
cycle_adj[1] <- 1/3

# Life-Expectancy via the discrete time Markov
payoff_living <- matrix(c(1,1,0),byrow=TRUE,ncol=1)
living <- as.matrix(tr_[,c("healthy","sick","dead")]) %*% payoff_living
living_alt <- as.matrix(tr_alt_[,c("healthy","sick","dead")]) %*% payoff_living

life_exp_markov <- 
    t(cycle_adj) %*% living 

life_exp_markov_alt <- 
    t(cycle_adj) %*% living_alt

# Life-Expectancy via the life table
life_exp_lifetable <- 
  lt %>% filter(age==starting_age) %>% pull(ex)

tibble(markov = as.vector(life_exp_markov), 
       markov_alt = as.vector(life_exp_markov_alt),life_table = life_exp_lifetable) %>% 
  kable(digits = 2) %>% 
  kable_styling()
```

What happens if we just put in a cause-specific hazard ratio that acts on the background mortality rate?

![](media/digraph-healthy-sick-dead-HR.png){fig-align="center" height="500px"}


```{r, eval = FALSE, echo = FALSE}
# Sketchviz code
digraph G {
    layout = neato;
    Healthy [pos="0,0!"];
    Sick [pos="1,1!"]; 
    Dead [pos="1,-1!"]
    Healthy -> Healthy ;
    Sick -> Sick;
    Healthy -> Sick [label="r_HS"]; 
    Sick -> Dead [label="  hr_SD * r_HD(t)" fontcolor="red"];
    Healthy -> Dead [label="r_HD(t)"];
    Dead -> Dead ;
}

```


```{r}
starting_age = .x = 40

tr_ <- tr_alt_ <- 
  bind_rows(c("healthy" = 1, "sick" = 0, "dead" = 0)) %>% mutate(t = 0) %>% select(t,healthy,sick,dead)

for (.x in 1:n_cycles) {
    
   r_death <- HP2(.x + starting_age - 1, params$heligman_bollard)$hx
    
      # Correct Version
    m_Q <-
        matrix(
            c(-(r_death + params$r_HS), params$r_HS, r_death,
                0, -(r_death * params$hr_S), r_death* params$hr_S,
              0,0,0),
            byrow = TRUE,
            ncol = 3,
            dimnames = list(c("healthy", "sick","dead"), c("healthy", "sick","dead"))
        )
    
    m_P <-
        expm(m_Q)
    
    # Using Formulas to Convert
    p_death <- 1 - exp(-r_death)
    p_sick <- 1 - exp(-params$r_HS)
    p_sick_death <- 1 - exp(-(r_death * params$hr_S))
    
    m_P_ <- 
      matrix(c(
       (1-p_death - p_sick), p_sick, p_death,
       0,(1-p_sick_death),p_sick_death,
       0,0,1
      ),
      byrow=TRUE,
      ncol = 3,
            dimnames = list(c("healthy", "sick","dead"), c("healthy", "sick","dead"))
      )
    
    tmp_ <- c(tr_[.x, "healthy"], tr_[.x, "sick"], tr_[.x, "dead"]) %>% unlist()
    
    tr_ <-
        bind_rows(
            tr_,
            (tmp_ %*% m_P)  %>% as.matrix() %>% data.frame() %>% mutate(t = .x) %>% select(t,healthy,sick,dead)
        )
    
    tmp_ <- c(tr_alt_[.x, "healthy"], tr_alt_[.x, "sick"], tr_alt_[.x, "dead"]) %>% unlist()
    
    tr_alt_ <-
        bind_rows(
            tr_alt_,
            (tmp_ %*% m_P_)  %>% as.matrix() %>% data.frame() %>% mutate(t = .x) %>% select(t,healthy,sick,dead)
        )
    
}

# Cycle adjustment
cycle_adj <- 
    c(rep(c(4/3,2/3),n_cycles/2),1/3)
cycle_adj[1] <- 1/3

# Life-Expectancy via the discrete time Markov
payoff_living <- matrix(c(1,1,0),byrow=TRUE,ncol=1)
living <- as.matrix(tr_[,c("healthy","sick","dead")]) %*% payoff_living
living_alt <- as.matrix(tr_alt_[,c("healthy","sick","dead")]) %*% payoff_living

life_exp_markov <- 
    t(cycle_adj) %*% living 

life_exp_markov_alt <- 
    t(cycle_adj) %*% living_alt

# Life-Expectancy via the life table
life_exp_lifetable <- 
  lt %>% filter(age==starting_age) %>% pull(ex)

tibble(markov = as.vector(life_exp_markov), 
       markov_alt = as.vector(life_exp_markov_alt),life_table = life_exp_lifetable) %>% 
  kable(digits = 2) %>% 
  kable_styling()
```

We no longer approximate the 'natural history' life-expectancy! Uh oh. 

Let's get an age-specific cause of death data from the [Global Burden of Disease](https://vizhub.healthdata.org/gbd-results/) project. 

These data summarize, by age group, the percentage of overall deaths that are attributable to cardiovascular disease. 

```{r}

ihme_cvd <- 
tibble::tribble(
        ~age_name,        ~val,
               1L, 0.038771524,
               5L, 0.038546046,
              10L, 0.044403585,
              15L, 0.033781126,
              20L, 0.035856165,
              25L, 0.053077797,
              30L, 0.086001439,
              35L, 0.130326551,
              40L, 0.184310334,
              45L,  0.21839762,
              50L, 0.243705394,
              55L, 0.256334637,
              60L,  0.26828001,
              65L, 0.272698709,
              70L,  0.28529754,
              75L, 0.310642009,
               0L, 0.016750489,
              80L, 0.353518012,
              85L, 0.399856716,
              90L, 0.447817792,
              95L, 0.495305502
        ) %>% 
    mutate(age_ihme = cut(age_name,unique(c(0,1,seq(0,95,5),105)),right=FALSE))  %>% 
    select(age_ihme,  pct_cvd = val) 
```

We now need to take our life table data and bin it similarly to the IHME data. 

```{r}
# Source: https://grodri.github.io/demography/neoplasms

# The time to death wtihin intervals is drawn from the "a" column here. 
# We really only use it for the 0-1 year old age range. 
# url = "https://grodri.github.io/datasets/preston41.dat"
# b41 <- read.table(url, header=FALSE)
# names(b41) <- c("age","D","Di","lx","a")

edit.na <- function(x, value) { x[is.na(x)] <- value; x}
    
lt_ <-
    lt %>% 
    mutate(age_ihme = cut(age,unique(c(0,1,seq(0,95,5),105)),right=FALSE)) %>% 
    left_join(ihme_cvd,"age_ihme") %>%
    mutate(dx_i = round(dx * pct_cvd)) %>% 
    select(age_ihme,
           age,
           D = dx,  # Deaths
           Di = dx_i, # Cause-specific deaths
           lx = lx) %>% # Living
    mutate(a = ifelse(age_ihme == "[0,1)", 0.152, 0.5)) %>% 

    # The conditional probability of dying of a given cause given survival to 
    # the age group is easy to obtain, we just multiply the overall probability 
    # by the ratio of deaths of a given cause to all deaths.
        
    mutate(q = edit.na(1 - lead(lx)/lx, 1),
           qi = q * Di/D) %>% 
    
    # The unconditional counts of deaths of any cause and of a given cause 
    # are calculated multiplying by the number surviving to the start of each 
    # age group, which is lx. Recall that to die of cause i in the interval 
    # [x, x+n) one must survive all causes up to age x.

    mutate(d = lx * q, 
           di = lx * qi) %>% 
    
    # In preparation for the next part, note that if we had nmx and we were willing 
    # to assume that the hazard is constant in each age group we would have had a 
    # slightly different estimate of the survival function. Let us “back out” 
    # the rates from the probabilities:
        
    mutate(n = c(diff(age),NA), 
           m =  edit.na( q/(n - q * (n - a)), 1/tail(a,1))) %>%  # m[last] = 1/a[last]
    
    # With these rates we compute the cumulative hazard and survival as
    
    mutate(H = cumsum(n * m), 
           S = edit.na(exp(-lag(H)), 1)) %>%  # S[1] = 1
        
    # We compute cause-specific rates by dividing deaths of a given cause into person-years 
    # of exposure, which is equivalent to multiplying the overall rate by the ratio of 
    # deaths of a given cause to the total. Here we want deaths for causes other than 
    # neoplasms. I will use the subscript d for deleted:
        
    mutate(Rd = (D - Di)/D,
           md = m * Rd) %>% 
    
    # We compute the conditional probability of surviving an age group after 
    # deleting a cause as the overall probability raised to Rd, and then calculate 
    # the survival function as a cumulative product
    
    mutate(pd = (1 - q)^Rd,
           ld = 100000 * cumprod(c(1, pd[-length(pd)]))) %>% 
    
    # Then we construct a survival function in the usual way, but treating this 
    # hazard as if it was the only one operating:
        
    mutate(Hd = cumsum(n * md), 
           Sd = edit.na(exp(-lag(Hd)), 1)) %>% # Sd[1] = 1 
    mutate(Pd =  edit.na((Sd - lead(Sd))/md, tail(Sd/md, 1))) %>% 
  
  # Now do it for cause-specific death. 
  
  mutate(Ri = Di / D, 
         pi = (1 - qi)^Ri,
         li = 100000 * cumprod(c(1, pi[-length(pi)]))) %>% 
  mutate(mi = m - md)

bx <- mutate(lt_, agem = age + n/2, mi = m - md)[-nrow(lt_), ]

ggplot(bx, aes(agem, m)) + geom_line() + scale_y_log10() +
  geom_line(aes(agem, md), col="red",linetype="dashed") + 
  geom_line(aes(agem, mi),col="blue")  + 
  labs(x = "Age", y = "Mortality Rate")


```


```{r}
ages_     <- lt_$age[lt_$age<=max_age & lt_$age>=min_age]
deaths_   <- lt_$d[lt_$age<=max_age & lt_$age>=min_age] - lt_$di[lt_$age<=max_age & lt_$age>=min_age]
exposure_  <- lt_$lx[lt_$age<=max_age & lt_$age>=min_age]

hp_fit_ <- MortalityLaw(
                x  = ages_,
                Dx  = deaths_,   # vector with death counts
                Ex  = exposure_, # vector containing exposures
                law = "HP2",
                opt.method = "LF2")
```

Now let's construct a model that adds in cause-specific death, and uses cause-deleted (modeled) mortality for secular death:

![](media/digraph-healthy-sick-dead-cause-deleted.png){fig-align="center" height="500px"}


```{r, eval = FALSE, echo = FALSE}
# Sketchviz code
digraph G {
    layout = neato;
    Healthy [pos="0,0!"];
    Sick [pos="1,1!"]; 
    Dead [pos="1,-1!"]
    Healthy -> Healthy ;
    Sick -> Sick;
    Healthy -> Sick [label="r_HS"]; 
    Sick -> Dead [label="  r_SD(t)" fontcolor="red"];
    Healthy -> Dead [label="r_HDd(t)" fontcolor="red"];
    Dead -> Dead ;
  }
```


```{r}
params <- modifyList(params, list(cause_deleted = coef(hp_fit_)))
starting_age = .x = 40

tr_ <- tr_alt_ <- 
  bind_rows(c("healthy" = 1, "sick" = 0, "cvddeath" = 0, "dead" = 0)) %>% mutate(t = 0) %>% select(t,healthy,sick,cvddeath,dead)

for (.x in 1:n_cycles) {
  
   current_age <- min(.x + starting_age - 1,max(lt_$age))
  
   r_death <- HP2(.x + starting_age - 1, params$cause_deleted)$hx
   r_cause <- lt_ %>% filter(age==current_age) %>% pull(mi)
    
    # Correct Version
    m_Q <-
        matrix(
            c(-(r_death + params$r_HS), params$r_HS, 0, r_death,
                0, -(r_cause+r_death), r_cause,r_death,
              0,0,0,0,
              0,0,0,0),
            byrow = TRUE,
            ncol = 4,
            dimnames = list( c("healthy", "sick","cvddeath","dead"), c("healthy", "sick","cvddeath","dead"))
        )
    
    m_P <-
        expm(m_Q)
    
    # Using Formulas to Convert
    p_death <- 1 - exp(-r_death)
    p_sick <- 1 - exp(-params$r_HS)
    p_sick_death <- 1 - exp(-(r_cause))
    
    m_P_ <- 
      matrix(c(
       (1-p_death - p_sick), p_sick, 0,p_death,
       0,(1-p_sick_death - p_death),p_sick_death,p_death,
       0,0,0,0,
       0,0,0,1
      ),
      byrow=TRUE,
      ncol = 4,
            dimnames = list(c("healthy", "sick","cvddeath","dead"), c("healthy", "sick","cvddeath","dead"))
      )
    
    tmp_ <- c(tr_[.x, "healthy"], tr_[.x, "sick"], tr_[.x, "cvddeath"],tr_[.x, "dead"]) %>% unlist()
    
    tr_ <-
        bind_rows(
            tr_,
            (tmp_ %*% m_P)  %>% as.matrix() %>% data.frame() %>% mutate(t = .x) %>% select(t,healthy,sick,cvddeath,dead)
        )
    
    tmp_ <- c(tr_alt_[.x, "healthy"], tr_alt_[.x, "sick"], tr_alt_[.x, "cvddeath"], tr_alt_[.x, "dead"]) %>% unlist()
    
    tr_alt_ <-
        bind_rows(
            tr_alt_,
            (tmp_ %*% m_P_)  %>% as.matrix() %>% data.frame() %>% mutate(t = .x) %>% select(t,healthy,sick,cvddeath,dead)
        )
    
}

# Cycle adjustment
cycle_adj <- 
    c(rep(c(4/3,2/3),n_cycles/2),1/3)
cycle_adj[1] <- 1/3

# Life-Expectancy via the discrete time Markov
payoff_living <- matrix(c(1,1,0,0),byrow=TRUE,ncol=1)
living <- as.matrix(tr_[,c("healthy","sick","cvddeath","dead")]) %*% payoff_living
living_alt <- as.matrix(tr_alt_[,c("healthy","sick","cvddeath","dead")]) %*% payoff_living

life_exp_markov <- 
    t(cycle_adj) %*% living 

life_exp_markov_alt <- 
    t(cycle_adj) %*% living_alt

# Life-Expectancy via the life table
life_exp_lifetable <- 
  lt %>% filter(age==starting_age) %>% pull(ex)

tibble(markov = as.vector(life_exp_markov), 
       markov_alt = as.vector(life_exp_markov_alt),life_table = life_exp_lifetable) %>% 
  kable(digits = 2) %>% 
  kable_styling()

```

Good news: we essentially replicate overall life expectancy! Though note the small difference with the model based on formula conversions rather than embedding. 

- Note that we used the cause-deleted life table's cause-specific mortality rate (`mi`) here. Another alternative would be to use a similar mortality model as above -- but in practice, for CVD deaths this does not yield good predictions for old ages (see plot )

```{r}
ages_     <- lt_$age[lt_$age<=max_age & lt_$age>=min_age]
deaths_i   <- lt_$di[lt_$age<=max_age & lt_$age>=min_age]
exposure_i  <- lt_$li[lt_$age<=max_age & lt_$age>=min_age]

hp_fit_i <- MortalityLaw(
                x  = ages_,
                Dx  = deaths_i,   # vector with death counts
                Ex  = exposure_i, # vector containing exposures
                law = "HP2",
                opt.method = "LF2")

params <- modifyList(params, list(cause_deleted = coef(hp_fit_),
                                  cause_specific = coef(hp_fit_i)))

plot(hp_fit_i)
```


# How Many People Become Sick?

Now we want to simply count up how many become sick. 

Can also use [Fernando's approach](https://journals.sagepub.com/doi/10.1177/0272989X19893973)

```{r}

starting_age = .x = 40
starting_pop = N

tr_ <-
  bind_rows(c("healthy" = N, "sick" = 0, "cvddeath" = 0, "dead" = 0, "accsick" = 0)) %>% mutate(t = 0) %>% select(t,healthy,sick,cvddeath,dead,accsick)

tr_alt_ <- 
  bind_rows(c("healthy" = N, "sick" = 0, "cvddeath" = 0, "dead" = 0)) %>% mutate(t = 0) %>% select(t,healthy,sick,cvddeath,dead)

tr_nodeath <- 
  bind_rows(c("healthy" = N, "sick" = 0)) %>% mutate(t = 0) %>% select(t,healthy,sick)

# transition array
arr_ <- arr_alt_ <- arr_nodeath <- list() 

for (.x in 1:n_cycles) {
  
   current_age <- min(.x + starting_age - 1,max(lt_$age))
  
   r_death <- HP2(.x + starting_age - 1, params$cause_deleted)$hx
   r_cause <- lt_ %>% filter(age==current_age) %>% pull(mi)
    
   m_Q_nodeath <- 
     matrix(
       c(-params$r_HS,params$r_HS,
         0,0),
       byrow=TRUE,
       ncol = 2, 
       dimnames = list(c("healthy","sick"),c("healthy","sick"))
     )
   
   m_P_nodeath <- 
     expm(m_Q_nodeath)
   
  tmp_nodeath <- c(tr_nodeath[.x, "healthy"], tr_nodeath[.x, "sick"]) %>% unlist()
    
  tr_nodeath <-
        bind_rows(
            tr_nodeath,
            (tmp_nodeath %*% m_P_nodeath)  %>% as.matrix() %>% data.frame() %>% mutate(t = .x) %>% select(t,healthy,sick)
        )
   
    # Correct Version
    m_Q <-
        matrix(
            c(-(r_death + params$r_HS), params$r_HS, 0, r_death,
                0, -(r_cause+r_death), r_cause,r_death,
              0,0,0,0,
              0,0,0,0),
            byrow = TRUE,
            ncol = 4,
            dimnames = list( c("healthy", "sick","cvddeath","dead"), c("healthy", "sick","cvddeath","dead"))
        )
    
    # Add the accumulator 
    m_Q_acc <- 
      cbind(rbind(m_Q,rep(0,nrow(m_Q))),rep(0,ncol(m_Q)+1))
    rownames(m_Q_acc) = c(rownames(m_Q),"accsick")
    colnames(m_Q_acc) = c(colnames(m_Q),"accsick")
    
    m_Q_acc["healthy","accsick"] <- m_Q_acc["healthy","sick"]

    m_P <-
        expm(m_Q_acc)
    
    # Using Formulas to Convert
    p_death <- 1 - exp(-r_death)
    p_sick <- 1 - exp(-params$r_HS)
    p_sick_death <- 1 - exp(-(r_cause))
    
    m_P_ <- 
      matrix(c(
       (1-p_death - p_sick), p_sick, 0,p_death,
       0,(1-p_sick_death - p_death),p_sick_death,p_death,
       0,0,0,0,
       0,0,0,1
      ),
      byrow=TRUE,
      ncol = 4,
            dimnames = list(c("healthy", "sick","cvddeath","dead"), c("healthy", "sick","cvddeath","dead"))
      )

    tmp_ <- c(tr_[.x, "healthy"], tr_[.x, "sick"], tr_[.x, "cvddeath"],tr_[.x, "dead"],tr_[.x,"accsick"]) %>% unlist()
    
    tr_ <-
        bind_rows(
            tr_,
            (tmp_ %*% m_P)  %>% as.matrix() %>% data.frame() %>% mutate(t = .x) %>% select(t,healthy,sick,cvddeath,dead,accsick)
        )
    
    arr_tmp <- diag(tmp_)
    arr_[[.x]] <- 
      arr_tmp %*% m_P
    
    tmp_alt_ <- c(tr_alt_[.x, "healthy"], tr_alt_[.x, "sick"], tr_alt_[.x, "cvddeath"], tr_alt_[.x, "dead"]) %>% unlist()
    
    tr_alt_ <-
        bind_rows(
            tr_alt_,
            (tmp_alt_ %*% m_P_)  %>% as.matrix() %>% data.frame() %>% mutate(t = .x) %>% select(t,healthy,sick,cvddeath,dead)
        )
    
    arr_alt_tmp <- diag(tmp_alt_)
    arr_alt_[[.x]] <- 
      arr_alt_tmp %*% m_P_
    
    
}

# Cycle adjustment
cycle_adj <- 
    c(rep(c(4/3,2/3),n_cycles/2),1/3)
cycle_adj[1] <- 1/3

# Embedded
payoff_sick <- matrix(c(0,0,0,0,1))
sick <- as.matrix(tr_[,c("healthy","sick","cvddeath","dead","accsick")]) %*% payoff_sick
sick_embedded <- t(cycle_adj) %*% sick

# Formulas
payoff_sick_alt <- matrix(c(0,1,0,0))
sick_alt <- as.matrix(tr_[,c("healthy","sick","cvddeath","dead")]) %*% payoff_sick_alt
sick_formula <- t(cycle_adj) %*% sick_alt

# No Death
payoff_sick_nodeath <- matrix(c(0,1))
sick_nodeath <- as.matrix(tr_nodeath[,c("healthy","sick")]) %*% payoff_sick_nodeath
sick_nodeath <- t(cycle_adj) %*% sick_nodeath

sick_nodeath
sick_formula
sick_embedded

```

Why the divergence? At later years the hazard of death is very high -- but the hazard of dying from CVD is also very high! 

Let's take a look at what happens in the first cycle. 

Here is the Markov trace for the embedded matrix:

```{r}
tr_[2,]
```

And here it is for the matrix constructed using conversion formulas:

```{r}
tr_alt_[2,]
```

We see that in both, `r tr_[2,"dead"] %>% round(0)` people die. But there are more people who remain sick in the trace based on the formulas (`r tr_alt_[2,"sick"] %>% round(0)`) than in the trace based on the embedded matrix (`r tr_[2,"sick"] %>% round(0)`). Why?

> `r tr_alt_[2,"sick"] %>% round(0)` is the total who would become sick *if we don't allow any death in the interval for those who would become sick in the interval*.  

That is, let's think about the population who would become sick in an interval. There are four mutually exclusive groups: 
  1. Individuals who become sick in the interval and stay sick throughout the interval. 
  2. Individuals who would have become sick in the interval, but died first. 
  3. Individuals who became sick in the interval, but *also* died from the illness within the interval.
  4. Individuals who became sick in the interval, but *also* died from background causes within the interval.
  
The total number `r tr_alt_[2,"sick"] %>% round(0)` sick at the end of the interval based on a matrix converted using standard formulas reflects the union of all the above. We're essentially "trapping" these patients within the interval and not allowing them to die for any other reason--either *before* or *after* they become ill.




  

