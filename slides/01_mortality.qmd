---
title: "1. Coping with Mortality"
editor: source
format:
  revealjs:
    transition: fade
background-transition: fade
incremental: true 
code-annotations: below
footer: |
    [Back to Website](../index.html)
editor_options: 
    chunk_output_type: console
self-contained: true
bibliography: references.bib
---

```{r setup}
source("manifest.r")
```

## Learning Objectives

-   Understand options for modeling background mortality based on life tables and parametric mortality models.
-   Construct a cause-deleted life table to model cause-specific and non-cause-specific death.

```{r}
#| warning: false
#| message: false
#| echo: false
#| code-fold: false
#############################################
# Define Parameters for Life Table Modeling
#############################################
mort_year =  # Year to obtain from Human Mortality Database
    2019
N = # Population basis for life table
    100000
max_age =  # Max age in life table
    99
min_age =  # Min age in life table
    0
n_cycles =  # Number of discrete time (annual) cycles in Markov
    100

###############################
# Underlying Life-Table Data
###############################

lt <-  # Read in the U.S. life table data from the human mortality database.
    read_rds(here("_sandbox/mortality/usa-life-table.rds")) %>% 
    lifetable(.,series = "total", years = mort_year) %>% 
    as_tibble() %>% 
    mutate_at(vars(lx,dx), function(x) x*N) %>% 
    mutate(country = "USA") %>% 
    mutate(age = x)
```

## Approaches to Modeling Mortality

::: nonincremental
-   Standard approach is to draw from life table data:
:::

```{r}
lt %>% 
    ungroup() %>% 
    select(-x) %>% 
    select(age,lx,dx,mx,qx) %>% 
    head(n=3) %>% 
    kable() %>% 
    kable_styling()
```

-   `lx` is the total number living in a hypothetical cohort (of 100,000).
-   `dx` is the number of deaths in the age interval.

## Approaches to Modeling Mortality

::: nonincremental
-   Standard approach is to draw from life table data:
:::

```{r}
lt %>% 
    ungroup() %>% 
    select(-x) %>% 
    select(age,lx,dx,mx,qx) %>% 
    head(n=3) %>% 
    kable() %>% 
    kable_styling()
```

-   `mx` is the death rate within the interval.
-   `qx` is the probability of death within an interval.

## Life Table Data

::: nonincremental
-   Death probabilities are useful for discrete time Markov models.
:::

```{r}
lt %>% 
    ungroup() %>% 
    select(-x) %>% 
    select(age,lx,dx,mx,qx) %>% 
    head(n=3) %>% 
    kable() %>% 
    kable_styling() %>% 
    column_spec(5, background = "#c6e6f5")

```

## Life Table Data

::: nonincremental
-   Death rates are useful for discrete event simulation (DES) models.
:::

```{r}
lt %>% 
    ungroup() %>% 
    select(-x) %>% 
    select(age,lx,dx,mx,qx) %>% 
    head(n=3) %>% 
    kable() %>% 
    kable_styling() %>% 
    column_spec(4, background = "#e8c6f5")

```

## Life Table-Based Mortality

::: nonincremental
-   A common approach is to use a life table-based lookup table in the model:
:::

```{r}
#| echo: TRUE
#| eval: FALSE
#| code-line-numbers: "2"
tpDn_lookup <-
    c("(34,44]" = 0.0017,  
      "(44,54]" = 0.0044,
      "(54,64]" = 0.0138,
      "(64,74]" = 0.0379,
      "(74,84]" = 0.0912,
      "(84,100]" = 0.1958)
```

-   Highlighted row: annual probability of death for 35-44 year old.

## Life Table-Based Mortality

-   What if age bins are coarse (e.g., 0, 5, 10,... vs. 0,1,2,3,...)?
    -   Assume death probability/rate is constant within age bins (and cycles)?
    -   In a DES model, we need to sample a time to death.
-   Can sample from survival function in underlying life table.
-   Ages in life table often topcoded (e.g., 85, 100, etc.)

## Alternative: Parametric Mortality Model

-   Fit a parametric mortality model to the life table data.
-   Reduces dimensionality to a few parameters.
-   Use these parameters to sample time of death, obtain mortality rate/probability at any arbitrary time, etc.

## Obtaining Life Table Data

::: {.callout-tip appearance="simple"}
The R packages `MortalityLaws` and `demography` facilitate life table data aquisition and modeling.
:::

Common sources:

-   [Human Mortality Database](https://www.mortality.org)
-   [Global Burden of Disease](https://www.healthdata.org/gbd)
-   [Human Cause of Death Database](https://www.causesofdeath.org/cgi-bin/main.php)
-   [Human Life Table Database](https://www.lifetable.de)

## Processing Life Table Data

-   Code below extracts U.S. life table data from the human mortality database (HMD).

## Processing Life Table Data

::: nonincremental
-   Code below extracts U.S. life table data from the human mortality database (HMD).
:::

```{r}
#| echo: true
#| eval: false
hmd_usa <-
    demography::hmd.mx("USA",
                       username = "<<your user name>>",
                       password = "<<your password>>", "USA")
```

## Processing Life Table Data

-   Code below processes HMD data and constructs a (2019) life table from it.
-   Radix (cohort size) is 100,000 individuals.

## Processing Life Table Data

::: nonincremental
-   Code below processes HMD data and constructs a (2019) life table from it.
-   Radix (cohort size) is 100,000 individuals.
:::

```{r}
hmd_usa <- 
    readRDS(url("https://github.com/graveja0/SMDM-Europe-2023/raw/main/_learnr/smdm-europe-2023-cvd-model/www/usa-life-table.rds"))
```

```{r}
#| echo: true

mortality_year = 2019 
radix = 100000

lt = 
    hmd_usa %>% 
    demography::lifetable(.,series = "total", years = mortality_year) %>% 
    as_tibble() %>% 
    rename(age = x) %>% 
    mutate_at(vars(lx,dx), function(x) x * radix) 
```

## US Life Table (2019)

Highlighted column: Remaining life expectancy at exact age x.

```{r}
lt %>% 
    select(age, lx, dx, ex, qx, mx) %>% 
    head(n=4) %>% 
    kable() %>% 
    kable_styling() %>% 
    column_spec(4, background = "#c6e6f5")
```

# Alive-Dead Model

## Alive-Dead Model

::: nonincremental
-   As a refresher, let's construct a very simple alive-dead model using life table death probability (`qx`) values.
:::

```{dot}
//| fig-align: center
//| fig-width: 10

digraph G {
    layout = neato;
    Alive [pos="0,0!"];
    Dead [pos="1,1.5!" ]
    Alive -> Alive [label="1.0-qx(t)"];
    Alive -> Dead [label="qx(t)" ];
    Dead -> Dead [label="1.0"];
  }
```

## Parameterize the model

```{r}
#| echo: true

params = 
  list(
    t_names = c("lifetable"),         # Strategy names. 
    n_treatments = 1,                 # Number of treatments
    s_names  = c("Alive", "Dead"),    # State names
    n_states = 2,                     # Number of states
    n_cohort = 100000,                # Cohort size
    initial_age = 0,                  # Cohort starting age    
    n_cycles = 110,                   # Number of cycles in model.  
    cycle = 1,                        # Cycle length
    life_table = lt                   # Processed HMD life table data (2019, USA)
  )

```

## Parameterize the model

```{r}
#| echo: true
#| code-line-numbers: "3-9"
params = 
  list(
    t_names = c("lifetable"),         # Strategy names. 
    n_treatments = 1,                 # Number of treatments
    s_names  = c("Alive", "Dead"),    # State names
    n_states = 2,                     # Number of states
    n_cohort = 100000,                # Cohort size
    initial_age = 0,                  # Cohort starting age    
    n_cycles = 110,                   # Number of cycles in model.  
    cycle = 1,                        # Cycle length
    life_table = lt                   # Processed HMD life table data (2019, USA)
  )

```

::: nonincremental
-   No specific strategies or policies under consideration; we're just trying to replicate mortality using life table data for a hypothetical cohort of 100,000 infants.
:::

## Parameterize the model

```{r}
#| echo: true
#| code-line-numbers: "10"
params = 
    list(
        t_names = c("lifetable"),         # Strategy names. 
        n_treatments = 1,                 # Number of treatments
        s_names  = c("Alive", "Dead"),    # State names
        n_states = 2,                     # Number of states
        n_cohort = 100000,                # Cohort size
        initial_age = 0,                  # Cohort starting age    
        n_cycles = 110,                   # Number of cycles in model.  
        cycle = 1,                        # Cycle length
        life_table = lt                   # Processed HMD life table data (2019, USA)
    )

```

::: nonincremental
-   Discrete time will be in annual cycles.
:::

## Parameterize the model

```{r}
#| echo: true
#| code-line-numbers: "11"
params = 
    list(
        t_names = c("lifetable"),         # Strategy names. 
        n_treatments = 1,                 # Number of treatments
        s_names  = c("Alive", "Dead"),    # State names
        n_states = 2,                     # Number of states
        n_cohort = 100000,                # Cohort size
        initial_age = 0,                  # Cohort starting age    
        n_cycles = 110,                   # Number of cycles in model.  
        cycle = 1,                        # Cycle length
        life_table = lt                   # Processed HMD life table data (2019, USA)
    )

```

::: nonincremental
-   The `lifetable` "strategy" will draw on the HMD life table data processed earlier.
:::

## Age-Dependent Transition Matrix

-   We'll next construct a transition probability matrix using the age-specific probability of death field (`qx`) from the life table data.

-   To do so, we need to define a function that, for a given age and cycle length, calculates the probability of death and places this within a transition matrix.

```{r}
#| echo: false
fn_mPt <- function(t, params)
{
  with(params, {
    h = cycle # Time step
    
    lapply(t, function(tt){
        current_age_lt <- pmin(initial_age  + (tt)*h - 1,max(lt$age))
        p_death <- lt[lt$age==current_age_lt,"qx"]
        p_death_modeled <- lt[lt$age==current_age_lt,"qx"]
        
        array(data = c(1 - p_death, 0, 
                 p_death,1,
                 
                 1 - p_death_modeled, 0, 
                 p_death_modeled,1),
              
              dim = c(n_states, n_states, n_treatments),
              dimnames = list(from = s_names,
                              to = s_names,
                              t_names)) #%>% 
          #apply(.,3,function(x) x, simplify = FALSE)  
    })
  })
}

```

## Age-Dependent Transition Matrix

```{r}
params$mP <- 
  fn_mPt(1:params$n_cycles, params)
```

::: columns
::: column
Life Table:

```{r}
#| echo: true
lt[1,c("age","qx")]
lt[90,c("age","qx")]
```
:::

::: column
Transition Matrix:

```{r}
#| echo: true
params$mP[[1]][,,"lifetable"]
params$mP[[90]][,,"lifetable"]
```
:::
:::

## Construct the Markov Trace

```{r}
#| echo: true
#| code-line-numbers: "2|3|6|8|9"
sim_cohort <- function(params) {
 params$t_names %>% map(~({ 
    tr_ <- t(c("alive" = params$n_cohort, "dead" = 0))
    
    res <- do.call(rbind,lapply(params$mP, function(tp) {
        tr_ <<- tr_ %*% matrix(unlist(tp[,,.x]),nrow=params$n_state)
    }))
    res <- rbind(c(params$n_cohort,0),res) 
    dimnames(res) <- list(paste0(c(0:params$n_cycles)), params$s_names)
    res
  })) %>% 
    set_names(params$t_names)
}
```

## Construct the Markov Trace

::: nonincremental
-   Output: named list object with full Markov trace for each state.
:::

## Construct the Markov Trace

::: nonincremental
-   Output: named list object with full Markov trace for each strategy.
:::

```{r}
#| echo: true
trace <- 
  sim_cohort(params)
trace[["lifetable"]][1:10,]
```

# Checkpoint: Life Expectancy at Birth

## Life Expectancy

-   We have a model with `r params$n_cycles` annual cycles for a cohort of `r formatC(params$n_cohort,format="d", big.mark=',')` `r params$initial_age` year olds.
-   According to the underlying life table data, life expectancy at birth is `r lt[1,] %>% pull(ex)` years.
-   Let's verify we can replicate this with our Markov model.

## Life Expectancy

::: nonincremental
-   We have a model with `r params$n_cycles` annual cycles for a cohort of `r formatC(params$n_cohort,format="d", big.mark=',')` `r params$initial_age` year olds.
-   According to the underlying life table data, life expectancy at birth is `r lt[1,] %>% pull(ex)` years.
-   Let's verify we can replicate this with our Markov model.
:::

```{r}

lt %>% 
    ungroup() %>% 
    select(age,qx,ex) %>% 
    head(n=1) %>% 
    kable() %>% 
    kable_styling() %>% 
    column_spec(3, background = "#c6e6f5")
```

## Life Expectancy

::: nonincremental
1.  Define the payoff for life expectancy (1 if alive, 0 otherwise)
:::

```{r}
#| echo: true
#| code-line-numbers: "1-2"

# Define the payoff for life expectancy
payoff_life_exp = c("Alive" = 1, "Dead" = 0) # <1>

# Calculate alive years in each cycle
life_exp_cycle = (trace[[1]] * (1 / params$n_cohort)) %*% payoff_life_exp  # <2>

# Function for cycle correction (alternative Simpson's method)
alt_simp_coef <- function(i) c(17, 59, 43, 49, rep(48, i-8),
                               49, 43, 59, 17) / 48
cycle_adj     <- function(x) sum(alt_simp_coef(length(x)) * x)

total_life_exp = cycle_adj(life_exp_cycle) # <3>
```

## Life Expectancy

::: nonincremental
2.  Calculate life years in each cycle.[^1]
:::

[^1]: Note that we divide by `r params$n_cohort` to normalize the results to a single individual for life expectancy calculations.

```{r}
#| echo: true
#| code-line-numbers: "4-5"

# Define the payoff for life expectancy
payoff_life_exp = c("Alive" = 1, "Dead" = 0) # <1>

# Calculate alive years in each cycle
life_exp_cycle = (trace[[1]] * (1 / params$n_cohort)) %*% payoff_life_exp  # <2>

# Function for cycle correction (alternative Simpson's method)
alt_simp_coef <- function(i) c(17, 59, 43, 49, rep(48, i-8),
                               49, 43, 59, 17) / 48
cycle_adj     <- function(x) sum(alt_simp_coef(length(x)) * x)

total_life_exp = cycle_adj(life_exp_cycle) # <3>
```

## Life Expectancy

::: nonincremental
3.  Define a function for cycle adjustment.[^2]
:::

[^2]: We use the alternative Simpson's method here for higher accuracy. The half-cycle correction is Newton's trapezoid method. See: Elbasha, Chhatwal, 2016 MDM.

```{r}
#| echo: true
#| code-line-numbers: "7-9"

# Define the payoff for life expectancy
payoff_life_exp = c("Alive" = 1, "Dead" = 0) # <1>

# Calculate alive years in each cycle
life_exp_cycle = (trace[[1]] * (1 / params$n_cohort)) %*% payoff_life_exp  # <2>

# Function for cycle correction (alternative Simpson's method)
alt_simp_coef <- function(i) c(17, 59, 43, 49, rep(48, i-8),
                               49, 43, 59, 17) / 48
cycle_adj     <- function(x) sum(alt_simp_coef(length(x)) * x)

total_life_exp = cycle_adj(life_exp_cycle) # <3>
```

## Life Expectancy

::: nonincremental
4.  Sum of values (with cycle adjustment applied) is total life expectancy.
:::

```{r}
#| echo: true
#| code-line-numbers: "11"

# Define the payoff for life expectancy
payoff_life_exp = c("Alive" = 1, "Dead" = 0) # <1>

# Calculate alive years in each cycle
life_exp_cycle = (trace[[1]] * (1 / params$n_cohort)) %*% payoff_life_exp  # <2>

# Function for cycle correction (alternative Simpson's method)
alt_simp_coef <- function(i) c(17, 59, 43, 49, rep(48, i-8),
                               49, 43, 59, 17) / 48
cycle_adj     <- function(x) sum(alt_simp_coef(length(x)) * x)

total_life_exp = cycle_adj(life_exp_cycle) # <3>
```

## Life Expectancy

```{r}
lt %>% 
    ungroup() %>% 
    select(age,ex) %>% 
    mutate(ex_markov = total_life_exp) %>% 
    head(n=1) %>% 
    kable(col.names = c("Age","Life Expectancy (Life Table data)",
                        "Life Expectancy (Markov-Life Table)")) %>% 
    kable_styling() 
```

-   We can repeat this exercise for different cohort starting ages and verify things line up.

## Life Expectancy

```{r}
#| fig-width: 7
#| fig-height: 5
#| fig-align: center

le_res <- lt %>% select(age,ex)

ages <- lt$age

le_res$ex_lt_markov = 
    ages %>% map_dbl(~({
        paramsX <- modifyList(params, list(initial_age=.x))
        paramsX$mP <- 
            fn_mPt(1:paramsX$n_cycles, paramsX)
        traceX <- 
            sim_cohort(paramsX)
        life_expX_cycle = (traceX[[1]] * (1 / paramsX$n_cohort)) %*% payoff_life_exp  # <2>
        total_life_expX = cycle_adj(life_expX_cycle) # <3>
        total_life_expX
    }))

le_res %>% 
    gather(method,value,-age) %>% 
    mutate(method = factor(method, labels = c("Life Table","Markov (Life Table qx)"))) %>% 
    ggplot(aes(x = age, y = value, colour = method)) + 
    geom_point() + 
    hrbrthemes::theme_ipsum_pub(base_family = "Arial") + 
    scale_colour_aaas(name = "") + 
    theme(legend.position = "top") 

```

# Mortality Modeling

## Mortality Modeling

-   Depending on context and modeling environment, you may need to model mortality.
-   The `MortalityLaws` package has a *number* of mortality models we can draw from:

## Mortality Modeling {.smaller}

```{r, results='asis'}
#| tbl-cap: Mortality Models in MortalityLaws package

type_lut <- c(
    "1"  =  "Infant mortality" ,             
    "2"  =  "Accident hump"      ,           
    "3"  =  "Adult mortality"   ,           
    "4"  =  "Adult and/or old-age mortality",
    "5"  =  "Old-age mortality"       ,      
    "6"  =  "Full age range" 
)

laws <- 
    availableLaws()$table %>% 
    as_tibble() %>% 
    arrange(TYPE) %>% 
    mutate(TYPE = type_lut[paste0(TYPE)]) %>% 
    #filter(CODE=="HP2") %>% 
    #mutate(MODEL = gsub("\\^","||",MODEL))
    mutate(MODEL = paste0("$",MODEL,"$")) %>% 
    mutate(MODEL = ifelse(CODE == "weibull","$\\mu[x] = 1/\\sigma * (x/M)^{(M/\\sigma - 1)}$",MODEL)) %>% 
    mutate(MODEL = ifelse(CODE == "invweibull","$\\mu[x] = 1/\\sigma * (x/M)^{[-M/\\sigma - 1]} / [\\exp((x/M)^{(-M/\\sigma)}) - 1]$",MODEL)) %>% 
    mutate(MODEL = ifelse(CODE == "perks","$\\mu[x] = [A + BC^x] / [BC^{-x} + 1 + DC^x]$",MODEL)) %>% 
    mutate(MODEL = ifelse(CODE == "wittstein","$q[x] = (1/B) A^{-[(Bx)^N]} + A^{-[(M-x)^N]}$",MODEL)) %>% 
    mutate(MODEL = ifelse(CODE == "HP","$q[x]/p[x] = A^{[(x + B)^C]} + D e^{-E \\log(x/F)^2} + G H^x$",MODEL)) %>% 
    mutate(MODEL = ifelse(CODE == "HP2","$q[x] = A^{[(x + B)^C]} + D e^{-E \\log(x/F)^2} + GH^x / [1 + GH^x]$",MODEL)) %>% 
    mutate(MODEL = ifelse(CODE == "HP3","$q[x] = A^{[(x + B)^C]} + D \\exp[-E \\log(x/F)^2] + GH^x / [1 + KGH^x]$",MODEL)) %>% 
    mutate(MODEL = ifelse(CODE == "HP3","$q[x] = A^{[(x + B)^C]} + D \\exp[-E \\log(x/F)^2] + GH^x / [1 + KGH^x]$",MODEL)) %>% 
    mutate(MODEL = ifelse(CODE == "kostaki","$q[x]/p[x] = A^{[(x+B)^C]} + D \\exp[-(E_i \\log(x/F_))^2] + G H^x$",MODEL)) %>%
    mutate(MODEL = ifelse(CODE == "opperman","$\\mu[x] = A/\\sqrt{x} - B + C\\sqrt{x}$", MODEL)) %>%
    mutate(MODEL = ifelse(CODE == "invgompertz","$\\mu[x] = [1-\\exp((M-x)/\\sigma)]/[\\exp((M-x)/\\sigma)-1]$",MODEL)) %>%
    mutate(MODEL = ifelse(CODE == "gompertz", "$\\mu[x] = A \\exp[Bx]$", MODEL)) %>%
    mutate(MODEL = ifelse(CODE == "gompertz0", "$\\mu[x] = 1/\\sigma \\exp[(x-M)/\\sigma]$", MODEL)) %>%
    mutate(MODEL = ifelse(CODE == "makeham", "$\\mu[x] = A \\exp[Bx] + C$", MODEL)) %>%
    mutate(MODEL = ifelse(CODE == "makeham0", "$\\mu[x] = 1/\\sigma \\exp[(x-M)/\\sigma)] + C$", MODEL)) %>%
    mutate(MODEL = ifelse(CODE == "strehler_mildvan", "$\\mu[x] = K \\exp[-V_0 (1-Bx)/D]$", MODEL)) %>%
    mutate(MODEL = ifelse(CODE == "vandermaen", "$\\mu[x] = A+Bx+Cx^2 + I/[N-x]$", MODEL)) %>%
    mutate(MODEL = ifelse(CODE == "beard", "$\\mu[x] = \\exp(Bx)/[1+KA \\exp(Bx)]$", MODEL)) %>%
    mutate(MODEL = ifelse(CODE == "beard_makeham", "$\\mu[x] = A \\exp(Bx)/[1 + KA \\exp(Bx)]$", MODEL)) %>%
    mutate(MODEL = ifelse(CODE == "ggompertz", "$\\mu[x] = A \\exp(Bx)/(1+AG/B[\\exp(Bx)-1])$", MODEL)) %>%
    mutate(MODEL = ifelse(CODE == "vandermaen2", "$\\mu[x] = A + Bx + I/[N-x]$", MODEL)) %>%
    mutate(MODEL = ifelse(CODE == "quadratic", "$\\mu[x] = A + Bx + Cx^2%", MODEL)) %>%
    mutate(MODEL = ifelse(CODE == "kannisto", "$\\mu[x] = A \\exp(Bx)/[1+A\\exp(Bx)]$", MODEL)) %>%
    mutate(MODEL = ifelse(CODE == "kannisto_makeham", "$\\mu[x] = A \\exp(Bx)/[1+A\\exp(Bx)]+C$", MODEL)) %>%
    mutate(MODEL = ifelse(CODE == "thiele", "$\\mu[a] = A e^{-Bx} + C e^{-\\frac{1}{2} D(x-E)^2}+F e^{Gx}$", MODEL)) %>%
    mutate(MODEL = ifelse(CODE == "martinelle", "$\\mu[x] = [A e^{Bx} + C]/[1+D e^{Bx}]+K e^{Bx}$", MODEL)) %>%
    mutate(MODEL = ifelse(CODE == "rogersplanck", "$q[x] = A_0 + A_1 e^{-Ax} + A_2 e^{B(x-u)-e^{-C(x-u)}}+A_3 e^{Dx}$", MODEL))

laws1 <- laws %>% 
    filter(TYPE %in% type_lut[1:2])

laws1 %>% 
    select(-YEAR,-TYPE,-FIT,-SCALE_X) %>% 
    kable(col.names = c("Name","Model","Code")) %>% 
    pack_rows(index = table(fct_inorder(laws1$TYPE))) %>%
    cat
```

##  {.smaller}

```{r, results='asis'}
laws2 <- laws %>% 
    filter(TYPE %in% type_lut[3:4])

laws2 %>% 
    select(-YEAR,-TYPE,-FIT,-SCALE_X) %>% 
    kable(col.names = c("Name","Model","Code")) %>% 
    pack_rows(index = table(fct_inorder(laws2$TYPE))) %>%
    cat
```

##  {.smaller}

```{r, results='asis'}
laws3 <- laws %>% 
    filter(TYPE %in% type_lut[5])

laws3 %>% 
    select(-YEAR,-TYPE,-FIT,-SCALE_X) %>% 
    kable(col.names = c("Name","Model","Code")) %>% 
    pack_rows(index = table(fct_inorder(laws3$TYPE))) %>%
    cat
```

##  {.smaller}

```{r, results='asis'}
laws4 <- laws %>% 
    filter(TYPE %in% type_lut[6]) %>% 
    filter(!(CODE %in% c("HP3","HP4","carriere2","siler")))

laws4 %>% 
    select(-YEAR,-TYPE,-FIT,-SCALE_X) %>% 
    kable(col.names = c("Name","Model","Code")) %>% 
    pack_rows(index = table(fct_inorder(laws4$TYPE))) %>%
    cat
```

## Mortality Modeling

-   Another nice feature of the package is that each mortality model type has its own defined function to calculate the mortality rate (or probability) given an age and model coefficients.

## Mortality Modeling

Generally speaking, we need three inputs:

-   `age`: Ages for lifetable
-   `dx`: The number of deaths between exact ages x and x+1.
-   `lx`: Number of survivors to exact age x.

## Gompertz Model

-   Because we want to stay general (i.e., model all over the age spectrum), our first attempt will be a Gompertz model.
-   Gompertz reduces mortality to two parameters.

## Gompertz Model

```{r}
#| warning: false
#| message: false
#| echo: true

ages     <- lt$age[lt$age<100]
deaths   <- lt$dx[lt$age<100]
exposure <- lt$lx[lt$age<100]

gom_fit <- MortalityLaw(
    x  = ages,      # vector with ages
    Dx  = deaths,   # vector with death counts
    Ex  = exposure, # vector containing exposures
    law = "gompertz",
    opt.method = "LF2")
```

## Gompertz Model

```{r, echo = TRUE}
# Fitted coefficients
gom_fit$coefficients
```

## Gompertz Model

```{r, echo = TRUE}
# Fitted coefficients
gom_fit$coefficients

# Hazard rate of death for a 40 year old based on Gompertz model
# mx = A exp(Bx)
gom_fit$coefficients["A"] * exp(gom_fit$coefficients["B"] * 40 )
```

## Gompertz Model

```{r, echo = TRUE}
# Fitted coefficients
gom_fit$coefficients

# Hazard rate of death for a 40 year old based on Gompertz model
# mx = A exp(Bx)
gom_fit$coefficients["A"] * exp(gom_fit$coefficients["B"] * 40 )

# Can simply use the supplied function to calcualte 
MortalityLaws::gompertz(x = 40, par = gom_fit$coefficients)

```

## Gompertz Model

```{r}
#| echo: true

# Calculate death hazard rate at age 40 from fitted Gompertz model. 
mx = gom_fit$coefficients["A"] * exp(gom_fit$coefficients["B"] * 40 )

```

## Gompertz Model

```{r}
#| echo: true

# Calculate death hazard rate at age 40 from fitted Gompertz model. 
mx = gom_fit$coefficients["A"] * exp(gom_fit$coefficients["B"] * 40 )

# Convert mortality rate to probability
-log(1-mx)
```

## Gompertz Model

```{r}
#| echo: true

# Calculate death hazard rate at age 40 from fitted Gompertz model. 
mx = gom_fit$coefficients["A"] * exp(gom_fit$coefficients["B"] * 40 )

# Convert mortality rate to probability
-log(1-mx)

# Compare with life table probability (qx) at age 40:
lt[41,c("age","qx")] 
```

## Gompertz Model

-   Gompertz doesn't fit all age ranges well---particularly young ages.
-   (This is a well-known fact in demography.)
-   If we were to focus only on adults, however, this would be a nice way to go.

## Gompertz Model

```{r, echo = TRUE}
plot(gom_fit)
```

## Gompertz Model

::: nonincremental
-   If we were to focus only on adults, however, this would be a nice way to go.
:::

## Gompertz Model: 40 Year Old Cohort

```{r}
#| warning: false
#| message: false
#| echo: true

ages     <- lt$age[lt$age>=40 & lt$age<100]
deaths   <- lt$dx[lt$age>=40 & lt$age<100]
exposure <- lt$lx[lt$age>=40 & lt$age<100]

gom_fit40 <- MortalityLaw(
                x  = ages,      # vector with ages
                Dx  = deaths,   # vector with death counts
                Ex  = exposure, # vector containing exposures
                law = "gompertz",
                opt.method = "LF2")
```

## Gompertz Model: 40 Year Old Cohort

```{r, echo = TRUE}
plot(gom_fit40)
```

## Heligman-Pollard

-   While you could draw from any of the aforementioned mortality models, the Heligman-Pollard model tends to fit the entire age distribution reasonably well.

-   Easy to use: just use `HP` in lieu of `gompertz`!

## Heligman-Pollard

::: nonincremental
-   While you could draw from any of the aforementioned mortality models, the Heligman-Pollard model tends to fit the entire age distribution reasonably well.

-   Easy to use: just use `HP` in lieu of `gompertz`!
:::

```{r}
#| warning: false
#| message: false
#| echo: true
#| code-line-numbers: "9"

ages     <- lt$age[lt$age<100]
deaths   <- lt$dx[lt$age<100]
exposure <- lt$lx[lt$age<100]

hp_fit <- MortalityLaw(
                x  = ages,      # vector with ages
                Dx  = deaths,   # vector with death counts
                Ex  = exposure, # vector containing exposures
                law = "HP",
                opt.method = "LF2")
```

## Heligman-Pollard

```{r, echo = TRUE}
plot(hp_fit)
```

## Heligman-Pollard

Mortality rate for a 40 year old:

```{r, echo = TRUE}
HP(x = 40, par = hp_fit$coefficients)
```

```{r, eval = FALSE, echo = TRUE}
x   = 40
mu1 = A^((x + B)^C) + G * H^x)
mu2 = D * exp(-E * (log(x/F_))^2))
eta = ifelse(x == 0, mu1, mu1 + mu2)
hx  = eta/(1 + eta)
```

## Death Hazard at Age 40: Gompertz vs. HP

```{r, echo = TRUE}
gompertz(x = 40, par = gom_fit$coefficients)$hx
HP(x = 40, par = hp_fit$coefficients)$hx
```

# Alive-Dead (Modeled Mortality)

## We'll Approach This From Two Angles

1.  Discrete Event Simulation: Sample a background mortality time.
2.  Discrete Time Markov: Use parameterized mortality in Alive-Dead model.

## 1. Sampling Death Dates (DES)

-   Difficult to sample death times from life tables due to coarseness of data (e.g., five-year age bins).
-   Solution:
    1.  Fit a parametric mortality model (e.g., Heligman-Pollard)
    2.  Construct a survival function from modeled hazards.
    3.  Sample a death time from the survival function.

## 1. Sampling Death Rates (DES)

-   Intuition is easier if we start with a defined quantile (e.g., 25th percentile of survival)

## 1. Sampling Death Rates (DES)

::: nonincremental
-   Intuition is easier if we start with a defined quantile (e.g., 25th percentile of survival)
:::

```{r}
#| echo: true
u = 0.25
```

## 1. Sampling Death Rates (DES)

::: nonincremental
-   We can feed the quantile (0.25) and coefficients into an inverse quantile function.
-   Straightforward to do for Gompertz model
:::

```{r}
#| echo: true
u = 0.25
qgompertz(p = u, shape = gom_fit$coefficients["B"], rate = gom_fit$coefficients["A"])
```

## 1. Sampling Death Rates (DES)

::: nonincremental
-   Let's verify this gets us close to what we see in the life table data.
:::

```{r}
#| echo: true
u = 0.25
qgompertz(p = u, shape = gom_fit$coefficients["B"], rate = gom_fit$coefficients["A"])
```

```{r}
lt %>% mutate(Sx = exp(-cumsum(mx))) %>% 
  filter(age>=70 & age<=72) %>% 
  select(age,mx,Sx) %>% 
  kable() %>% 
  kable_styling() %>% 
  column_spec(3, background = "#c6e6f5")
```

## 1. Sampling Death Rates (DES)

-   There is no inverse quantile function for Heligman-Pollard, but we can create one!

## 1. Sampling Death Rates (DES)

::: nonincremental
-   There is no inverse quantile function for Heligman-Pollard, but we can create one!
-   Approxfun returns a function that provides a value of `y` for a given value of `x`.
:::

```{r}
#| echo: true
qHP <- 
  approxfun(y = 0:115,
            x = 1 - exp(-cumsum(HP(x = 0:115, par = hp_fit$coefficients)$hx)))
```

## 1. Sampling Death Rates (DES)

-   For `approxfun()`:
    -   `x` is quantile in CDF for survival, i.e., 1 - Survival[^3]
    -   `y` is the age.
-   So qHP(0.5) would return median survival age in the modeled data.

[^3]: Recall that survival is $\exp(-H)$, where $H$ is the cumulative hazard

## 1. Sampling Death Rates (DES)

```{r}
#| echo: true
qHP <- 
  approxfun(y = 0:115,
            x = 1 - exp(-cumsum(HP(x = 0:115, par = hp_fit$coefficients)$hx)))
qHP(0.25)
```

Survival in life table:

```{r}
lt %>% mutate(Sx = exp(-cumsum(mx))) %>% 
  #filter(age>=82 & age<=83) %>% 
  filter(age>=70 & age<=72) %>% 
  select(age,mx,Sx) %>% 
  kable() %>% 
  kable_styling() %>% 
  column_spec(3, background = "#c6e6f5")
```

## 1. Sampling Death Rates (DES)

-   We now have the tools we need to sample death times that closely match underlying mortality data!
-   For a given simulated patient, sample a uniform (0,1) and feed this number into the inverse quantile function.

## 1. Sampling Death Rates (DES)

::: nonincremental
-   We now have the tools we need to sample death times that closely match underlying mortality data!
-   For a given simulated patient, sample a uniform (0,1) and feed this number into the inverse quantile function.
:::

```{r}
#| echo: true

# Sample death times for 10 individuals
u <- runif(10, min = 0, max = 1)
qHP <- 
  approxfun(y = 0:115,
  x = 1 - exp(-cumsum(HP(x = 0:115, par = hp_fit$coefficients)$hx)))
qHP(u)
```

## 2. Modeled Mortality (Markov)

-   Let's now incorporate modeled mortality parameters into our Alive-Dead model.
-   Rather than draw a probability of death from the life table data, we'll calculate the probability of death at a given age using the model coefficients.

## Parameterize the model

```{r}
#| echo: true

params = 
  list(
    t_names = c("lifetable",          # Strategy names
                "heligman-pollard",
                "gompertz"),          
    n_treatments = 3,                 # Number of treatments
    s_names  = c("Alive", "Dead"),    # State names
    n_states = 2,                     # Number of states
    n_cohort = 100000,                # Cohort size
    initial_age = 40,                 # Cohort starting age    
    n_cycles = 110,                   # Number of cycles in model.  
    cycle = 1,                        # Cycle length
    life_table = lt,                  # Processed HMD life table data (2019, USA)
    gom_fit = gom_fit,                # Fitted Gompertz model object
    hp_fit = hp_fit                   # Fitted Heligman-Pollard model object
  )

```

## Age-Dependent Transition Matrices {.smaller}

```{r}
#| echo: true
fn_mPt <- function(t, params) {
  with(params, {
    h = cycle # Time step
    lapply(t, function(tt){
       # Life table method
        current_age_lt = pmin(initial_age  + (tt)*h - 1,max(lt$age))
        p_death <- lt[lt$age==current_age_lt,"qx"]
        # parametric mortality methods
        current_age = initial_age  + (tt)*h - 1
        r_death_gompertz <- gompertz(current_age,params$gom_fit$coefficients)$hx
        p_death_gompertz <- 1 - exp(-r_death_gompertz)
        r_death_hp <- HP(current_age, params$hp_fit$coefficients)$hx
        p_death_hp <- 1 - exp(-r_death_hp)
        
        array(data = c(1 - p_death, 0, 
                 p_death,1,
                 
                 1 - p_death_hp, 0, 
                 p_death_hp,1,
                 
                1 - p_death_gompertz, 0, 
                 p_death_gompertz,1),
              
              dim = c(n_states, n_states, n_treatments),
              dimnames = list(from = s_names,
                              to = s_names,
                              t_names)) 
    })
  })
}
```

## Construct a Markov Trace

```{r}
#| echo: true
# Add transition matrices into params.
params$mP <- 
  fn_mPt(1:params$n_cycles, params)

# Construct the Markov trace. 
trace <- 
  sim_cohort(params)
```

## Construct a Markov Trace

::: columns
::: {.column width="33%"}
```{r, echo = TRUE}
trace[["lifetable"]][1:10,]

```
:::

::: {.column width="33%"}
```{r, echo = TRUE}
trace[["gompertz"]][1:10,]
```
:::

::: {.column width="33%"}
```{r, echo = TRUE}
trace[["heligman-pollard"]][1:10,]
```
:::
:::

## Calculate Life Expectancy

```{r}
#| echo: true
# Define the payoff for life expectancy
payoff_life_exp = c("Alive" = 1, "Dead" = 0) # <1>

# Calculate alive years in each cycle
life_exp_cycle = lapply(trace, function(tr) (tr * (1 / params$n_cohort)) %*% payoff_life_exp)  # <2>

# Function for cycle correction (alternative Simpson's method)
alt_simp_coef <- function(i) c(17, 59, 43, 49, rep(48, i-8),
                               49, 43, 59, 17) / 48
cycle_adj     <- function(x) sum(alt_simp_coef(length(x)) * x)

total_life_exp = lapply(life_exp_cycle,cycle_adj) # <3>
```

## Life Expectancy: Alive-Dead Model

```{r}
#| echo: true
total_life_exp
```

# Cause-Deleted Mortality

## Motivation

-   Often, background mortality is drawn directly from life table data.
-   Models also frequently include cause-specific death as a separate tracked event or health state.

## Motivation

-   This approach "double-counts" death because cause-specific death is also reflected in the life table estimates!
-   OK if cause-specific death is a small contributor to overall death rates.
-   But what if modeled disease is a frequent cause of death (e.g., cardiovascular disease, cancer)?

## Solution

-   We can construct an alternative life table that "nets out" cause-specific deaths.
-   Not foolproof: need to make an assumption that we can parse out deaths as indepdendent contributors to overall mortality.

# CVD Natural History Model

## CVD Natural History Model

-   Next set of slides will walk through the process of constructing a natural history model for cardiovascular disease.
-   We'll construct a model with non-CVD background mortality, and CVD mortality.
-   First step is constructing a cause-deleted life table.
    -   Needed because at older ages, CVD is a substantial contributor (\~50%) of overall mortality.

## CVD-Deleted Life Table

Constructing the cause-deleted life table **requires two necessary inputs**:

1.  Overall mortality by age.
2.  Cause-specific mortality by age (ideally as a % of all deaths at a given age).

-   These are obtainable for many countries from the Global Burden of Disease and Human Cause of Death Database websites.

## CVD-Deleted Life Table

::: nonincremental
-   Our estimates of CVD death by age will be drawn from the [Global Burden of Disease](https://vizhub.healthdata.org/gbd-results/) website.
:::

![Screenshot of Global Burden of Disease Data](images/gbd-cvd-deaths.png){height="500px"}

## 

We extract the percentage of overall deaths that are from CVD by age bin:

```{r, echo = TRUE}
ihme_cvd <- 
  tibble::tribble(
        ~age_name,        ~val,
               1, 0.038771524,
               5, 0.038546046,
              10, 0.044403585,
              15, 0.033781126,
              20, 0.035856165,
              25, 0.053077797,
              30, 0.086001439,
              35, 0.130326551,
              40, 0.184310334,
              45,  0.21839762,
              50, 0.243705394,
              55, 0.256334637,
              60,  0.26828001,
              65, 0.272698709,
              70,  0.28529754,
              75, 0.310642009,
               0, 0.016750489,
              80, 0.353518012,
              85, 0.399856716,
              90, 0.447817792,
              95, 0.495305502
        ) %>% 
    mutate(age_ihme = cut(age_name,unique(c(0,1,seq(0,95,5),105)),right=FALSE))  %>% 
    select(age_ihme,  pct_cvd = val) 
```

## 

Merge these percentages into the underlying life table data and use them to calculate the total number of CVD deaths by age:

```{r}
lt_ <-  # 
    lt %>% 
    mutate(age_ihme = cut(age,unique(c(0,1,seq(0,95,5),105)),right=FALSE)) %>% 
    left_join(ihme_cvd,"age_ihme") %>%
    mutate(dx_i = round(dx * pct_cvd)) %>% 
    select(age,
           age_ihme,
           pct_cvd,
           dx,  # Deaths
           dx_i, # Cause-specific deaths
           lx) %>% # Living
    mutate(a = ifelse(age==0, 0.152, 0.5)) %>% # time lived by deaths in age group
    mutate(age_interval = c(diff(age), NA)) %>% 
    select(age,age_ihme,pct_cvd, lx,dx,dx_i,a,age_interval) %>% 
    # Probability of death in interval =  deaths / total living at beginning of interval. 
    mutate(q = replace_na(1 - lead(lx) / lx, 1))  %>% 
      # Convert probability to rate. Note that we could also use q/(age_interval - q * (age_interval - a))
    mutate(m = -log(1-q)/age_interval) 
  

lt_ %>% 
  select(age,age_ihme,pct_cvd,dx,dx_i) %>% 
  filter(age %in% c(0,10,25,50,75,98))  %>% 
  kable() %>% 
  kable_styling()
```

## 

We next calculate the cause-deleted probability of death (`qd`) and death rate (`md`), as well as the cause-specific probability of death (`qi`) and death rate (`mi`):

## Steps

1.  Cause-specific probability of death (`qi`): $q \cdot dx_i / dx$
2.  Cacluate cause-specific rates by dividing deaths of a given cause into person-years of exposure.

-   This is equivalent to multiplying the overall rate by the ratio of deaths of a given cause to the total.

## Steps

::: nonincremental
1.  Cause-specific probability of death (`qi`): $q \cdot dx_i / dx$
2.  Cacluate cause-specific rates by dividing deaths of a given cause into person-years of exposure.
    -   This is equivalent to multiplying the overall rate by the ratio of deaths of a given cause to the total.
:::

```{r  echo = TRUE}
lt_ <- 
  lt_ %>% 
    # Cause specific probability of death. 
    mutate(qi = q * dx_i / dx) %>% 
    mutate(Rd = (dx - dx_i) / dx) %>% 
    mutate(md = m * Rd) %>% 
    mutate(mi = m - md) %>% 
    mutate(dxd = dx - dx_i)
```

## 

```{r}
lt_ %>% 
  select(age, dx, dxd, dx_i, q, qi, md, mi) %>% 
  head() %>% 
  kable() %>% 
  kable_styling()
```

## Modeling CVD-Deleted Mortality

-   We can also apply the methods covered earlier to the cause-deleted life table data!

```{r , echo = TRUE}
ages_     <- lt_$age[lt_$age<100 & lt_$age>=25]
deaths_   <- lt_$dxd[lt_$age<100 & lt_$age>=25] 
exposure_  <- lt_$lx[lt_$age<100 & lt_$age>=25]

mort_fit_CVDdeleted <- MortalityLaw(
    x  = ages_,
    Dx  = deaths_,   # vector with death counts
    Ex  = exposure_, # vector containing exposures
    law = "HP2",
    opt.method = "LF2")

```

## 

```{r}
params = 
  list(
    t_names = c("natural_history"),       # Strategy names. 
    n_treatments = 1,                     # Number of treatments
    s_names  = c("Healthy", "CVD","CVDDeath","Dead"),
    n_states = 4,                         # Number of states
    n_cohort = 100000,                    # Cohort size
    initial_age = 25,                      # Cohort starting age    
    n_cycles = 100,                       # Number of cycles in model.  
    cycle = 1,                            # Cycle length
    r_H_CVD = 0.1,                        # Healthy -> CVD transition rate
    u_H = 1,                              # Utility state payoffs
    u_CVD = 1,
    u_D = 0,
    u_DCVD = 0,
    c_H = 0,                              # Cost state payoffs
    c_CVD = 0,
    c_DCVD = 0,
    c_D = 0, 
    cause_specific_mortality =            # Cause specific morality rate
      approxfun(lt_$age, lt_$mi,rule = 2),
    mort_fit = mort_fit_CVDdeleted        # Cause-Deleted Mortality Fit 
  )

```

## Basic CVD Model

```{dot}
digraph G {
    layout = neato;
    Healthy [pos="0,0!"];
    CVD [pos="1,1!"]; 
    "Dead\n(CVD)" [pos="3.1,-.5!"]
    Dead [pos="1,-1!"]
    Healthy -> Healthy ;
    CVD -> CVD;
    CVD -> "Dead\n(CVD)" [label = "    r_DCVD(t)        " labeldistance=1]
    Healthy -> CVD [label="r_HS"]; 
    CVD -> Dead [label="  r_HD(t)"];
    Healthy -> Dead [label="r_HD(t)"];
    Dead -> Dead ;
    "Dead\n(CVD)" -> "Dead\n(CVD)"
}

```

## Basic CVD Model

::: nonincremental
-   Healthy {{< fa arrow-right >}} Death based on modeled (Heligman-Pollard) cause-deleted mortality.
:::

```{dot}
digraph G {
    layout = neato;
    Healthy [pos="0,0!"];
    CVD [pos="1,1!"]; 
    "Dead\n(CVD)" [pos="3.1,-.5!"]
    Dead [pos="1,-1!"]
    Healthy -> Healthy ;
    CVD -> CVD;
    CVD -> "Dead\n(CVD)" [label = "    r_DCVD(t)        " labeldistance=1]
    Healthy -> CVD [label="r_HS"]; 
    CVD -> Dead [label="  r_HD(t)"];
    Healthy -> Dead [label="r_HD(t)" fontcolor="red"];
    Dead -> Dead ;
    "Dead\n(CVD)" -> "Dead\n(CVD)"
}

```

## Basic CVD Model

::: nonincremental
-   CVD {{< fa arrow-right >}} Death based on age- and cause-specific death rates from cause-deleted life table.
:::

```{dot}
digraph G {
    layout = neato;
    Healthy [pos="0,0!"];
    CVD [pos="1,1!"]; 
    "Dead\n(CVD)" [pos="3.1,-.5!"]
    Dead [pos="1,-1!"]
    Healthy -> Healthy ;
    CVD -> CVD;
    CVD -> "Dead\n(CVD)" [label = "    r_DCVD(t)        " labeldistance=1 fontcolor="red"]
    Healthy -> CVD [label="r_HS"]; 
    CVD -> Dead [label="  r_HD(t)"];
    Healthy -> Dead [label="r_HD(t)"];
    Dead -> Dead ;  
    "Dead\n(CVD)" -> "Dead\n(CVD)"
}

```

## Basic CVD Model

::: nonincremental
-   We also allow for a CVD {{< fa arrow-right >}} Death transition based on non-CVD causes.
:::

```{dot}
digraph G {
    layout = neato;
    Healthy [pos="0,0!"];
    CVD [pos="1,1!"]; 
    "Dead\n(CVD)" [pos="3.1,-.5!"]
    Dead [pos="1,-1!"]
    Healthy -> Healthy ;
    CVD -> CVD;
    CVD -> "Dead\n(CVD)" [label = "    r_DCVD(t)        " labeldistance=1 ]
    Healthy -> CVD [label="r_HS"]; 
    CVD -> Dead [label="  r_HD(t)" fontcolor="red"];
    Healthy -> Dead [label="r_HD(t)"];
    Dead -> Dead ;
    "Dead\n(CVD)" -> "Dead\n(CVD)"
}

```

## Age-Dependent Transition Matrices

```{r}
fn_mPt_CVD <- function(t, params) {
  with(params, {
    h = cycle # Time step
    lapply(t, function(tt){
       # Life table method
        current_age = initial_age  + (tt)*h - 1
        
        r_H_D <- HP(current_age, params$mort_fit$coefficients)$hx
        r_CVD_D = params$cause_specific_mortality(current_age) 
        
        R <- array(data = c(
                      -(r_H_D+params$r_H_CVD),0,0,0, 
                      params$r_H_CVD,-(r_CVD_D+r_H_D),0,0, 
                      0,r_CVD_D,0,0,
                      r_H_D,r_H_D,0,0),
                      
              
              dim = c(n_states, n_states, n_treatments),
              dimnames = list(from = s_names,
                              to = s_names,
                              t_names)) 
        P = apply(R,3,expm, simplify=FALSE)
        P
    })
  })
}
params$mP <- fn_mPt_CVD(1:params$n_cycles,params)
```

## Construct a Markov Trace

```{r}
sim_cohort <- function(params) {
  
 params$t_names %>% map(~({ 
    tr_ <- t(c(params$n_cohort,rep(0,params$n_states - 1)))
    
    res <- do.call(rbind,lapply(params$mP, function(tp) {
        tr_ <<- tr_ %*% matrix(unlist(tp[[.x]]),nrow=params$n_state)
    }))
    res <- rbind(c(params$n_cohort,rep(0,params$n_states - 1)),res) 
    dimnames(res) <- list(paste0(c(0:params$n_cycles)), params$s_names)
    res
  })) %>% 
    set_names(params$t_names)
}
```

```{r}
#| echo: true
trace <- 
  sim_cohort(params)
trace[["natural_history"]][1:10,]
```

## Good News

-   Modeled CVD and non-CVD mortality closely matches the cause-deleted life table data!

```{r}
#| fig-align: center
#| fig-width: 6
lt_compare <- 
    lt_ %>% 
    mutate(dx = dx - dx_i) %>% 
    select(age = age, dead_lt = dx, cvddeath_lt = dx_i) %>% 
    mutate(age = age + 1) %>% 
    filter(age>=params$initial_age) %>% 
    mutate(dead_lt = ifelse(age==25,0,dead_lt),
           cvddeath_lt = ifelse(age==25,0,cvddeath_lt)) %>% 
    mutate_at(vars(dead_lt,cvddeath_lt), cumsum)


trace[["natural_history"]] %>% 
    data.frame() %>% 
    tibble() %>% 
    set_names(c("healthy","cvd","cvddeath","dead")) %>% 
    mutate(age = params$initial_age  + (row_number())*params$cycle - 1 ) %>% 
    select(age,cvddeath,dead) %>% 
    inner_join(lt_compare, "age") %>% 
    gather(state,value,-age) %>% 
    mutate(state = factor(state,levels = c("cvddeath","cvddeath_lt","dead","dead_lt"), 
                          labels = c("CVD Deaths",
                                     "CVD Deaths (Life Table)",
                                     "Non-CVD Mortality",
                                     "Non-CVD Mortality (Life Table)"))) %>% 
    mutate(state1 = ifelse(grepl("CVD Deaths",state),"CVD Deaths","Non-CVD Mortality")) %>% 
    mutate(state2 = ifelse(grepl("Life Table",state),"Life Table","Markov")) %>% 
    ggplot(aes(x = age, y = value, colour = state2)) + 
    geom_line(aes(lty=state1))  +
    hrbrthemes::theme_ipsum(base_family = "Arial") + 
    scale_colour_aaas(name="") + 
    scale_linetype(guide="none") +
    geom_dl(method = list("last.bumpup",hjust=1),aes(label=state1),colour = "black") +
    theme(legend.position="top") + 
    labs(x = "Age", y = "Deaths") + 
    scale_y_continuous(limits = c(0,radix)) 
```

# Your Turn
