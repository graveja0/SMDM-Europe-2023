---
title: "Incorporating New Evidence and Uncertainty"
subtitle: "Solving for PSA Parameters and Copula-Based PSA Sampling"
editor: source
format:
  revealjs:
    transition: fade
    background-transition: fade
    incremental: true 
    footer: |
      [Back to Website](../index.html)
editor_options: 
  chunk_output_type: console
self-contained: true
bibliography: references.bib
---

```{r setup}
source("./manifest.r")
```

# Some PSA Notes

- Taking 95% CI and turning them into distribution parameters for PSA draws is a common task.
- Analytic formulas: https://www.johndcook.com/quantiles_parameters.pdf
- ParameterSolver implemented in Windows, [Link](https://biostatistics.mdanderson.org/SoftwareDownload/SingleSoftware/Index/6)

## Scenario

- Your model has a rate `rH_CVD` and you want to define a probabilistic sensitivity analysis (PSA) distribution around it.




## Common PSA Distributions

| Parameter Type                  | Distribution     |
|---------------------------------|------------------|
| Probability                     | beta             |
| Rate                            | gamma            |
| Utility weight                  | beta             |
| Right skew (e.g., cost)         | gamma, lognormal |
| Relative risks or hazard ratios | lognormal        |
| Odds Ratio                      | logistic         |

## Normal Distribution Analytic

Let $x_1$ and $x_2$ represent desired end points at some confidence interval $p_1$ and $p_2$. For 95% CI, $p_1=0.025$ and $p_2=0.975$

$$ \sigma = \frac{x_2 - x_1}{\Phi^{-1}(p_2)-\Phi^{-1}(p_1)}$$

$$\mu = \frac{x_1\Phi^{-1}(p_2)-x_2\Phi^{-1}(p_1)}{\Phi^{-1}(p_2)-\Phi^{-1}(p_1)}$$

## Normal Distribution Example

```{r}
#| echo: true
param_normal <- function(x1,x2,p1,p2) {
  sigma <- (x2 - x1) / (qnorm(p2)-qnorm(p1))
  mu <- (x1*qnorm(p2)-x2*qnorm(p1))/(qnorm(p2)-qnorm(p1));
  c("mu" = mu, "sigma" = sigma)
}
param_normal(x1 = 0.91, p1 = 0.025, x2 = 1.69, p = 0.975)
```

```{r}
curve(dnorm(x, 1.3, 0.199), from=0.8, to=1.8, ylab="")
abline(v=0.91, col='red')
abline(v=1.69, col='red')
```

## Gamma Example

```{r}
#| echo: true
gamma_fn <- function(x1, p1, x2, p2, alpha)
  x1*qgamma(p2,shape = alpha) - x2*qgamma(p1, shape = alpha)

param_gamma <- function(x1,x2,p1,p2,range) {
    alpha <- uniroot(function(a) gamma_fn(x1,p1,x2,p2,a),range)$root
    beta  <- x1 / qgamma(p1,alpha)
    c("alpha" = alpha, "beta" = beta)
}

param_gamma(x1=0.91, p1=0.025, x2=1.69, p2=0.975, range = c(1,100))
```

```{r}
curve(dgamma(x, shape=40.59, scale=0.0313), from = 0.5, to=2)
abline(v=0.91, col='red')
abline(v=1.69, col='red')
```

## General Optimization Technique

::: nonincremental
-  General solution, requires cumulative distribution function (CDF), $F$.
-  https://hwborchers.lima-city.de/Presents/ROptimSlides4.pdf for optimization tutorial in R 
:::
 
$$\min_{\vec{\theta} \in R}\,\, (F(x_1|\vec{\theta})-p_1)^2+(F(x_2|\vec{\theta})-p_2)^2$$

## Normal via Optim

-  Expected 1.30000 0.19898
-  **Not the right answer!**

```{r}
#| echo: true
library(pracma)
norm <- function(x1, p1, x2, p2, mu, sigma)
 (pnorm(x1, mu, sigma)-p1)^2 +
 (pnorm(x2, mu, sigma)-p2)^2

fn <- function(x) norm(0.91, 0.025, 1.69, 0.975, x[1], x[2])

optim(c(0.5, 0.1),
      fn,
      gr = function(x) pracma::grad(fn, x),
      lower=c(-Inf, 1e-4),
      method = "L-BFGS-B",
      control=list(factr=1e-10, maxit=100))$par

```



## Normal via Optim

::: nonincremental
-  Note that the function is on the probability scale.
-  We have seen issues with probability before.
-  Note the gradient of the tails.  

:::

```{r}
curve(pnorm(x), from=-10, to=10, lwd=3, col='red')
```


## Stable Optimization

::: nonincremental
- Analytically correct formula is not numerically stable.
- Transfinite scaling stabilizes optimization.
- For probabilities, this is the $\text{logit}(p)=\log \frac{p}{1-p}=\log p - \log (1-p)$.
- Tweaking parameters to converge can still happen.
- Example of theory versus practice.
:::

$$\min_{\vec{\theta} \in R} \sum_{i \in 1,2}\,\, (\text{logit} (F(x_i|\vec{\theta}))-\text{logit} (p_i))^2$$

## Transfinite Example

```{r}
#| echo: true
Tf <- function(x, mu, sigma) # Stable Logit for *any* distribution
    pnorm(x, mu, sigma, log=TRUE) -
    pnorm(x, mu, sigma, log=TRUE, lower.tail=FALSE)

norm <- function(x1, p1, x2, p2, mu, sigma)
 (Tf(x1, mu, sigma)-(log(p1)-log(1-p1)) )^2 +
 (Tf(x2, mu, sigma)-(log(p2)-log(1-p2)) )^2

fn <- function(x) norm(0.91, 0.025, 1.69, 0.975, x[1], x[2])

optim(c(0.5, 0.1),
      fn,
      gr = function(x) pracma::grad(fn, x),
      lower=c(-Inf, 1e-5),
      method = "L-BFGS-B",
      control=list(factr=1e-10, maxit=100))$par

```

## Summary on Distribution Fitting

- Use analytical formulas if they exist.
- Optimize on $\text{logit}$ scale.
- Again, avoid $\log$ on probabilities, use `log=TRUE`.
- Plot results for visual check.




# Copulas

## What is a Copula?

-   The binding "glue" between correlated variables.
-   

## Copulas and PSA Sampling {auto-animate="true"}

We typically draw PSA samples from the *marginal* distribution of each variable:

$$
F_1(x_1),  ..., F_d(x_d)
$$

## Copulas and PSA Sampling {auto-animate="true"}

Copulas allow us to sample from the *joint* distribution:

$$
F(x_1,...,x_d) = C \big ( F_1(x_1), ..., F_d(x_d) \big )
$$

(This is a result of Sklar \[1959\].)

## Copulas and PSA Sampling {auto-animate="true"}

-   Copula: a multivariate cumulative distribution function with uniform marginals.
