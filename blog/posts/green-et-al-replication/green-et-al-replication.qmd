---
title: "Replication of Didactic Model"
editor: visual
editor_options: 
  chunk_output_type: console
execute: 
  cache: false
---

# Introduction

<div><a href='//sketchviz.com/@graveja0/87115c93ff6ac666674b88e1b30aec15'><img src='https://sketchviz.com/@graveja0/87115c93ff6ac666674b88e1b30aec15/696391f92d96cd0be0fe09157ba6247d0dd84cc9.sketchy.png' style='max-width: 100%;'></a><br/><span style='font-size: 80%;color:#555;'>Created on <a href='//sketchviz.com/' style='color:#555;'>Sketchviz</a></span></div>


```{r setup}
#| echo: false
#| warning: false
#| message: false
library(tidyverse)
library(demography)
library(MortalityLaws)
library(directlabels)
library(ggsci)
library(hrbrthemes)
library(MASS)
library(mgcv)
library(patchwork)
library(knitr)
library(kableExtra)
library(here)
library(ggsci)
library(expm)
library(glue)
select =dplyr::select
options("scipen" = 100, "digits" = 5)
```


Here is a footnote reference,[^1] and another.[^longnote]

[^1]: Here is the footnote.

[^longnote]: Here's one with multiple blocks.

    Subsequent paragraphs are indented to show that they
belong to the previous footnote.

        { some.code }

    The whole paragraph can be indented, or just the first
    line.  In this way, multi-paragraph footnotes work like
    multi-paragraph list items.

This paragraph won't be part of the note, because it
isn't indented.


## Cycle Adjustment
We first define some necessary functions for bookkeeping later. 

```{r}
alt_simp_coef <- function(i) c(17, 59, 43, 49, rep(48, i-8), 49, 43, 59, 17) / 48 # <1>
cycle_adj      <- function(x,h) h*sum(alt_simp_coef(length(x)) * x) # <2>
```
1. Alternative Simpson's method coefficients
2. Function to create cycle adjustment values

## Model Parameters



```{r}
params = list(
    t_names = c("without_drug", "with_drug"),
    n_treatments =2,
    s_names  =c("Asymptomatic_disease", "Progressive_disease", "DeadCause","Dead"),
    n_states =4,
    a_names = c("accProgressive_disease"),
    tunnel_names = c("trProgressive","trDeadCause"),
    
    n_cohort =1000,
    cycle =1,
    
    n_cycles = 46,
    Initial_age =55,
    effect =0.5, 
    
    cAsymp =500,
    cDeath =1000,
    cDrug =1000,
    cProg =3000,
    uAsymp =0.95,
    uProg =0.75,
    oDr = 0,# 0.06,
    cDr = 0, # 0.06,
    tpDcm =0.15,
    tpProg =0.01,
    tpDn =0.0379 
    
)
```

## Transition Probability Matrices

```{r}
m_Pt <- function(t) {
    lapply(t, function(tt){
        
        current_age <- params$Initial_age  + (tt) - 1
        cycle = tt
        
        tpDn_lookup <-
            c("(34,44]" = 0.0017,
              "(44,54]" = 0.0044,
              "(54,64]" = 0.0138,
              "(64,74]" = 0.0379,
              "(74,84]" = 0.0912,
              "(84,100]" = 0.1958)
        
        age_grp <- cut(current_age, 
                       breaks = c(34,44,54,64,74,84,100))
        tpDn <- tpDn_lookup[age_grp]

        tpProg_ <- params$tpProg * (cycle )
        tpDcm_ <- params$tpDcm 
        effect_ <- params$effect
        n_states_ <- params$n_states
        s_names_ <- params$s_names
        t_names_ <- params$t_names
        n_treatments_ <- params$n_treatments
        
 
        m_P_ <- 
            array(data = c(0, 0, 0,0,
                           tpProg_, 0, 0,0,
                           0,tpDcm_+tpDn,0,0,
                           tpDn ,  0, 0,0,
                           
                           0, 0, 0,0,
                           tpProg_*(1-effect_), 0, 0,0,
                           0,tpDcm_+tpDn,0,0,
                           tpDn,  0,0, 0),
                  dim = c(n_states_, n_states_, n_treatments_),
                  dimnames = list(from = s_names_,
                                  to = s_names_,
                                  t_names_))
        diag(m_P_[,,1]) <- 1 - rowSums(m_P_[,,1])
        diag(m_P_[,,2]) <- 1 - rowSums(m_P_[,,2])
        m_P <- list()
        m_P[[1]] <- m_P_[,,1]
        m_P[[2]] <- m_P_[,,2]

        return(m_P)
    })
}

m_P <- m_Pt(1:(params$n_cycles-1))
```

```{r}
m_P[[1]]
```

## Payoffs

```{r}
u_payoff <- with(params,{
    array(c("Asymptomatic_disease" = uAsymp, "Progressive_disease" = uProg, "DeadCause" = 0, "Dead" = 0, 
            "Asymptomatic_disease" = uAsymp, "Progressive_disease" = uProg,  "DeadCause" = 0, "Dead" = 0 ),
          dim = c(1, n_states, n_treatments),
          dimnames = list(from = "cost",
                          to = c(s_names),
                          t_names))
})

c_payoff <- with(params,{
    array(c("Asymptomatic_disease" = cAsymp, "Progressive_disease" = cProg, "DeadCause" = 0 , "Dead" = 0, 
            "Asymptomatic_disease" = cAsymp+cDrug, "Progressive_disease" = cProg, "DeadCause" = 0 , "Dead" = 0 ),
          dim = c(1, n_states, n_treatments),
          dimnames = list(from = "cost",
                          to = c(s_names),
                          t_names))
})

c_transition_payoff <- with(params,{
    array(c("Asymptomatic_disease" = 0, "Progressive_disease" = 0, "DeadCause" = cDeath , "Dead" = 0, 
            "Asymptomatic_disease" = 0, "Progressive_disease" = 0, "DeadCause" = cDeath , "Dead" = 0 ),
          dim = c(1, n_states, n_treatments),
          dimnames = list(from = "cost",
                          to = c(s_names),
                          t_names))
})
```

```{r}
sim_cohort <- function(params) {
    
    m_P <- m_Pt(1:(params$n_cycles-1))
    
    tr <- 
        m_P %>% transpose() %>% 
        map(~({
            tr_ <- t(c("Asymptomatic_disease" = 1000, "Progressive_disease" = 0, "DeadCause" = 0, "Dead" = 0))
            do.call(rbind,lapply(.x, function(tp) {
                tr_ <<- tr_ %*% tp
            }))
        }))
    tr <- 
        tr %>% 
        map(~({
            .x <- rbind(t(c(1000,0,0,0)),.x)
        }))
    
    return(tr)
}

markov_trace <- 
    markov_trace <- sim_cohort(params)

state_costs_without <- markov_trace[[1]] %*% c_payoff[,,1]
transition_costs_without <- matrix(c(0,diff(markov_trace[[1]][,"DeadCause"]))) * params$cDeath
costs_without <- state_costs_without + transition_costs_without
qalys_without <- markov_trace[[1]] %*% u_payoff[,,1]

state_costs_with <- markov_trace[[2]] %*% c_payoff[,,2]
transition_costs_with <- matrix(c(0,diff(markov_trace[[2]][,"DeadCause"]))) * params$cDeath
costs_with <- state_costs_with + transition_costs_with
qalys_with <- markov_trace[[2]] %*% u_payoff[,,2]

cycle_adj <- alt_simp_coef(params$n_cycles)
discounting <- 1/(1+params$oDr)^(0:(params$n_cycles-1))

tot_costs_without <- sum(as.vector(costs_without[-1]) * discounting[-1])
tot_costs_with <- sum(as.vector(costs_with[-1])  * discounting[-1])

tot_qalys_without <- sum(as.vector(qalys_without) *  discounting)
tot_qalys_with <- sum(as.vector(qalys_with) *  discounting)

#inc_cost <- (tot_costs_with - tot_costs_without) 
inc_qaly <- (tot_qalys_with - tot_qalys_without); inc_qaly
inc_cost <- (tot_costs_with - tot_costs_without); inc_cost

icer = inc_cost / inc_qaly ; icer

```

